[{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_AutoSmCCNet.html","id":"automated-smccnet","dir":"Articles","previous_headings":"","what":"Automated SmCCNet","title":"Automated SmCCNet","text":"version SmCCNet package, introduce pipeline known Automated SmCCNet. method streamlines SmCCNet code significantly reduces computation time. Users simply required input list omics data phenotype variable. program automatically determines whether dealing single-omics multi-omics problem, whether use CCA PLS quantitative binary phenotypes respectively. details method established parameters coefficients set, recommend user refer multi-omics single-omics vignettes. Specifically, multi-omics SmCCNet, CCA employed, program can automatically select scaling factors (importance pair-wise omics omics-phenotype correlations objective function). achieved calculating pairwise canonical correlation pair omics stringent penalty parameters. scaling factor omics data , B pair SmCCA set absolute value pairwise canonical correlation omics B divided omics correlation shrinkage parameter. default, scaling factors linked phenotype-specific correlation structure set 1. Automated SmCCNet, users need provide BetweenShrinkage parameter, positive real number helps reduce significance omics-omics correlation component. larger number, omics correlation shrunk. Moreover, multi-omics SmCCNet binary phenotype, scaling factor implemented. However, user need provide values \\(\\gamma_1\\) (omics-omics connection importance) \\(\\gamma_2\\) (omics-phenotype connection importance, see multi-omics vignette section 5 detail). automated SmCCNet program offers method calculate \\(\\gamma_1\\) setting value \\(\\gamma_2\\) 1. generally done averaging pairwise omics-omics canonical correlations multi-omics dataset. program can also automatically select percentage features subsampled. number features omics data less 300, percentage feature subsampled set 0.9, otherwise, ’s set 0.7. candidate penalty terms range 0.1 0.5 step size 0.1 single/multi-omics SmCCA, 0.5 0.9 step size 0.1 single/multi-omics SPLSDA (omics-omics SmCCA step omics-phenotype classifier, see section 5 multi-omics vignette detail). automated version SmCCNet typically faster standard SmCCNet. due heuristic selection scaling factors (see section 4.2 multi-omics vignette), parallelization cross-validation step, resulting substantial increase computational speed. example implement Automated SmCCNet. detailed information, please refer FastAutoSmCCNet() function help file:","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_AutoSmCCNet.html","id":"function-arguments-and-tuning-parameters","dir":"Articles","previous_headings":"","what":"Function Arguments and Tuning Parameters","title":"Automated SmCCNet","text":"X: list omics matrices set order subjects Y: Phenotype variable either numeric binary, binary variable, binary Y, binarized 0 1 running function. AdjustedCovar: data frame covariates interest adjusted regressing-approach, preprocess must set TRUE. Kfold: Number folds cross-validation, default set 5. EvalMethod: single multi-omics binary phenotype, evaluation methods used selected optimal penalty parameter(s). selections among ‘accuracy’, ‘auc’, ‘precision’, ‘recall’, ‘f1’, default set ‘accuracy’. subSampNum: Number subsampling run, higher better terms accuracy, cost computational time, generally recommend 500-1000 increase robustness. BetweenShrinkage: real number > 0 helps shrink importance omics-omics correlation component, larger number , greater shrinkage , default set 2. ScalingPen: numeric vector length 2 used penalty terms scaling factor selection method, default set 0.1, 0 1. DataType: vector indicating omics type element X, example c(‘gene’, ‘miRNA’). CutHeight: numeric value specifying cut height hierarchical clustering, 0 1, default set \\(1-0.1^{10}\\). min_size: Minimally possible subnetwork size network pruning, default set 10. max_size: Maximally possible subnetwork size network pruning, default set 100. summarization: Summarization method used network pruning summarization, either ‘NetSHy’ ‘PCA’, default set ‘NetSHy’. saving_dir: Directory user like store subnetwork results, default set current working directory. preprocess: TRUE FALSE, Whether data preprocessing step conducted, default set FALSE. covariates adjustment needed, add covariates AdjustedCovar argument. ncomp_pls: Number components PLS algorithm, used binary phenotype given, default set 3. tuneLength: total number candidate penalty term values omics data, default set 5. tuneRangeCCA: vector length 2 represents range candidate penalty term values omics data based canonical correlation analysis, default set c(0.1,0.5). tuneRangePLS: vector length 2 represents range candidate penalty term values omics data based partial least squared discriminant analysis, default set c(0.5,0.9). seed: Random seed result reproducibility, default set 123.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_AutoSmCCNet.html","id":"examples","dir":"Articles","previous_headings":"","what":"Examples","title":"Automated SmCCNet","text":"present examples execute Automated SmCCNet using simulated dataset. demonstration, simulate four datasets: two omics data one phenotype data. cover four cases total, involving combinations single multi-omics data either quantitative binary phenotype. final case demonstrates use regress-approach covariate adjustment. users want run pipeline step--step understand algorithm used, please refer SmCCNet single multi-omics vignettes details. Global network information stored object ‘result’, subnetwork information stored directory user provide. information using Cytoscape visualize subnetworks, please refer back multi-omics vignette section 3.1.","code":"library(SmCCNet) set.seed(123) data(\"ExampleData\") Y_binary <- ifelse(Y > quantile(Y, 0.5), 1, 0) # single-omics PLS result <- fastAutoSmCCNet(X = list(X1), Y = as.factor(Y_binary),                            Kfold = 3,                            subSampNum = 100, DataType = c('Gene'),                           saving_dir = getwd(), EvalMethod = 'auc',                            summarization = 'NetSHy',                            CutHeight = 1 - 0.1^10, ncomp_pls = 5) # single-omics CCA result <- fastAutoSmCCNet(X = list(X1), Y = Y, Kfold = 3,                            preprocess = FALSE,                           subSampNum = 50, DataType = c('Gene'),                           saving_dir = getwd(), summarization = 'NetSHy',                           CutHeight = 1 - 0.1^10) # multi-omics PLS result <- fastAutoSmCCNet(X = list(X1,X2), Y = as.factor(Y_binary),                            Kfold = 3, subSampNum = 50,                            DataType = c('Gene', 'miRNA'),                            CutHeight = 1 - 0.1^10,                           saving_dir = getwd(),                            EvalMethod = 'auc',                            summarization = 'NetSHy',                           BetweenShrinkage = 5,                            ncomp_pls = 3) # multi-omics CCA result <- fastAutoSmCCNet(X = list(X1,X2), Y = Y,                            K = 3, subSampNum = 50,                            DataType = c('Gene', 'miRNA'),                            CutHeight = 1 - 0.1^10,                           saving_dir = getwd(),                             summarization = 'NetSHy',                           BetweenShrinkage = 5)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"smccnet-overview","dir":"Articles","previous_headings":"","what":"SmCCNet overview","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"Note: use SmCCNet published research, please cite: Liu, W., Vu, T., Konigsberg, . R., Pratte, K. ., Zhuang, Y., & Kechris, K. J. (2023). SmCCNet 2.0: Upgraded R package Multi-omics Network Inference. bioRxiv, 2023-11. Shi, W. J., Zhuang, Y., Russell, P. H., Hobbs, B. D., Parker, M. M., Castaldi, P. J., … & Kechris, K. (2019). Unsupervised discovery phenotype-specific multi-omics networks. Bioinformatics, 35(21), 4336-4343.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"workflow","dir":"Articles","previous_headings":"SmCCNet overview","what":"Workflow","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"SmCCNet canonical correlation based integration method reconstructs phenotype-specific multi-omics networks (Shi et al., 2019). algorithm based sparse multiple canonical analysis (SmCCA) \\(T\\) omics data \\(X_1, X_2,...X_T\\) quantitative phenotype \\(Y\\) measured subjects. SmCCA finds canonical weights \\(w_1, w_2,...,w_T\\) maximize (weighted unweighted) sum pairwise canonical correlations \\(X_1, X_2, ..., X_T\\) \\(Y\\), constraints (Equation \\(\\ref{eq:smcca2}\\)). SmCCNet, sparsity constraint functions \\(P_t(\\cdot), t = 1,2,...,T\\), least absolute shrinkage selection operators (LASSO). weighted version corresponds \\(a_{,j}, b_{}\\) (also called scaling factors), equal; unweighted version corresponds \\(a_{,j} = b_i = 1\\) \\(,j = 1,2,..., T\\). \\[\\begin{equation} \\begin{split} \\label{eq:smcca2} & (w_1, w_2,...,w_T)\\!  =\\! \\arg\\max_{\\tilde w_1, \\tilde w_2,..., \\tilde w_T} \\!\\left(\\sum_{<j;,j=1,2,...,T} \\!a_{,j}\\tilde w_i^TX_i^TX_j\\tilde w_j\\! +\\! \\sum_{=1}^{T}b_{}  \\tilde w_i^TX_i^TY\\!\\right),\\\\ &  \\hspace{.2in}\\text{subject } \\lVert\\tilde w_t\\rVert^2 = 1, P_t(\\tilde w_t) \\leq c_t, t = 1,2,...,T.            \\end{split} \\end{equation}\\] sparsity penalties \\(c_t\\) influence many features included subnetwork. pre-selected sparsity penalties, SmCCNet algorithm creates network similarity matrix based SmCCA canonical weights repeated subsampled omics data phenotype, finds multi-omics modules relevant phenotype. subsampling scheme improves network robustness analyzing subset omics features multiple times forms final similarity matrix aggregating results subsampling step. general workflow (Figure \\(\\ref{fig:flowchart}\\)) involves three steps: Step : Determine SmCCA sparsity penalties \\(c_t\\). user can select penalties omics feature selection based study purpose /prior knowledge. Alternatively, one can pick sparsity penalties based K-fold cross validation (CV) procedure minimizes total prediction error (Figure \\(\\ref{fig:CVflow}\\)). K-fold CV procedure ensures selected penalties generalizable similar independent data sets prevents -fitting. Step II: Randomly subsample omics features without replacement, apply SmCCA chosen penalties, compute feature relationship matrix subset. Repeat process many times define similarity matrix average feature relationship matrices. Step III: Apply hierarchical tree cutting similarity matrix find multi-omics networks. step simultaneously identifies multiple subnetworks. SmCCNet workflow overview Quantitative Phenotype. X1, X2, X3 three omics data types set n subjects. Y indicates quantitative phenotype measure n subjects. Note flowchart demonstrate workflow three omics data, also compatible three omics data two omics data.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"smccnet-package","dir":"Articles","previous_headings":"SmCCNet overview","what":"SmCCNet package","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"SmCCNet package following dependencies: older version SmCCNet package includes four (external) functions: getRobustPseudoWeights(): Compute aggregated (SmCCA) canonical weights. getAbar(): Calculate similarity matrix based canonical weights. getMultiOmicsModules(): Perform hierarchical tree cutting similarity matrix extract clades multi-omics features. plotMultiOmicsNetwork(): Plot (pruned full) multi-omics subnetworks. updated package, functions except getAbar retired package, additional functions added package perform single-/multi-omics SmCCNet quantitative/binary phenotype, use illustrated vignette: aggregateCVSingle(): Saving cross-validation result cross-validation table working directory provide recommendation penalty term selection. classifierEval(): Evaluate binary classifier’s performance respect user-selected metric (accuracy, auc score, precision, recall, f1). dataPreprocess(): simple pipeline preprocess data running SmCCNet (center, scale, coefficient variation filtering regressing covariates). fastAutoSmCCNet(): Automated SmCCNet automatically identifies project problem (single-omics vs multi-omics), type analysis (CCA quantitative phenotype vs. PLS binary phenotype) based input data provided. method automatically preprocess data, choose scaling factors, subsampling percentage, optimal penalty terms, runs complete SmCCNet pipeline without requirement users provide additional information. function store subnetwork information user-provided directory, well return global network evaluation information. Refer automated SmCCNet vignette information. getCanWeightsMulti(): Run Sparse Multiple Canonical Correlation Analysis (SmCCA) return canonical weight. getCanCorMulti(): Get canonical correlation value SmCCA given canonical weight vectors scaling factors. getRobustWeightsMulti(): SmCCNet algorithm multi-omics data quantitative phenotype. Calculate canonical weights SmCCA. getRobustWeightsMultiBinary(): SmCCNet algorithm multi-omics data binary phenotype. First, SmCCA used identify relationship omics (exlude phenotype). , highly connected omics features selected step 1, SPLSDA used identify relationships omics features phenotype(s). sparse PLSDA algorithm binary outcome first compute PLS assuming outcome continuous, extracts multiple latent factors, uses latent factors fit logistic regression, weights latent factor regression parameters. getRobustWeightsSingle(): Compute aggregated (SmCCA) canonical weights single omics data quantitative phenotype. getRobustWeightsSingleBinary(): Compute aggregated (SmCCA) canonical weights single omics data binary phenotype. getOmicsModules(): Perform hierarchical tree cutting similarity matrix extract clades omics features. networkPruning(): Extract summarization scores (first 3 NetSHy/regular prinicipal components) specified network module given network size. omics features ranked based PageRank algorithm, top \\(m\\) omics features (\\(m\\) specified subnetwork size) included final subnetwork generate summarization score. PC score, correlation respect phenotype interest calculated stored. addition, correlation individual omics features detected phenotype (Pheno argument) also recorded. final subnetwork adjacency matrix stored user-specified working directory interest. scalingFactorInput(): inputing annotation omics data, uses prompts ask user supply scaling factor intended SmCCNet algorithm prioritize correlation structure interest. scaling factor values supplied numeric nonnegative. summarizeNetSHy(): Implement NetSHy network summarization via hybrid approach summarize network considering network topology Laplacian matrix. details functions can found package manual.","code":"library(pbapply) library(Matrix) library(igraph) library(SmCCNet) library(furrr) library(future)"},{"path":[]},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"synthetic-dataset","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset","what":"Synthetic dataset","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"example, consider synthetic data set 500 genes \\((X_1)\\) 100 miRNAs \\((X_2)\\) expression levels measured 358 subjects, along quantitative phenotype \\((Y)\\). Denote number features \\(X_1 \\& X_2\\) \\(p_1 \\& p_2\\) respectively, number subjects \\(n\\). Although SmCCNet require normality, calculates Pearson correlation linear combinations omics features phenotype, assumes finite variances finite covariance. necessary include transformation data skewed. algorithm also requires data standardizable (.e. none data matrices include column zero variance.)","code":"data(ExampleData) head(X1[ , 1:6]) ##          Gene_1   Gene_2   Gene_3   Gene_4   Gene_5   Gene_6 ## Samp_1 22.48570 40.35372 31.02575 20.84721 26.69729 30.20545 ## Samp_2 37.05885 34.05223 33.48702 23.53146 26.75463 31.73594 ## Samp_3 20.53077 31.66962 35.18957 20.95254 25.01883 32.15723 ## Samp_4 33.18689 38.48088 18.89710 31.82330 34.04938 38.79989 ## Samp_5 28.96198 41.06049 28.49496 18.37449 30.81524 24.00454 ## Samp_6 18.05983 29.55471 32.54002 29.68452 26.19996 26.76684 head(X2[ , 1:6]) ##           Mir_1    Mir_2    Mir_3    Mir_4    Mir_5     Mir_6 ## Samp_1 15.22391 17.54583 15.78472 14.89198 10.34821  9.689755 ## Samp_2 16.30697 16.67283 13.36153 14.48855 12.66090 11.333613 ## Samp_3 16.54512 16.73501 14.61747 17.84527 13.82279 11.329333 ## Samp_4 13.98690 16.20743 16.29308 17.72529 12.30056  9.844108 ## Samp_5 16.33833 17.39387 16.39792 15.85373 13.38767 10.599414 ## Samp_6 14.54110 16.51999 14.73958 15.87504 13.21359 10.922393 head(Y) ##           Pheno ## Samp_1 235.0674 ## Samp_2 253.5450 ## Samp_3 234.2050 ## Samp_4 281.0354 ## Samp_5 245.4478 ## Samp_6 189.6231 p1 <- ncol(X1) p2 <- ncol(X2) n <- nrow(X1) AbarLabel <- c(colnames(cbind(X1, X2)))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-i--preprocessing","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset","what":"Step I. Preprocessing","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"first step preprocess single omics data. canonical correlation analysis (CCA) methods require data sets standardized (centered scaled) columns (e.g. features) ensure equivalent contribution feature maximizing covariance. addition, optional steps preprocess data. Note employing standardization covariate adjustment, essential apply standardization prior covariate adjustment. sequencing ensures best efforts meet assumptions linear regression. data preprocessing pipeline, following options given: CoV Filtering: Filter features based coefficients variation (CoV). Standardization: Center /scale data. Adjust Covariates: Regress specified covariates return residuals example data preprocessing feature filtering standardization, case, covariate adjustment, coeffcient variation filtering quantile 0.2 (meaning features CoV smaller 20% quantile CoV filtered ), data centered scaled:","code":"# define data list X <- list(X1, X2) # preprocess data processed_data <- lapply(X, function(Xmatrix){   as.matrix(dataPreprocess(X = as.data.frame(Xmatrix), covariates = NULL,                    is_cv = TRUE, cv_quantile = 0.2, center = TRUE,                   scale = TRUE))}) # re-standardize -omics data if regress-out approach is used (covariates != NULL) processed_data <- lapply(processed_data, scale) # if preprocess feature is used, X need to be overrided with the following code  X <- processed_data"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-ii-determine-optimal-sparsity-penalties-through-cross-validation-optional","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset","what":"Step II: Determine optimal sparsity penalties through cross-validation (optional)","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"two omics data, find optimal sparsity penalties \\(c_1, c_2\\), apply K-fold CV synthetic data (Figure \\(\\ref{fig:CVflow}\\)). Note LASSO constraints, \\(1\\leq c_1\\leq\\sqrt{p_1s_1}, 1\\leq c_2\\leq\\sqrt{p_2s_2}\\), \\(p_1,p_2\\) denote number features omics data \\(X_1, X_2\\) respectively, \\(s_1, s_2\\) proportions \\(X_1, X_2\\) features sampled every time. sparse penalties \\(c_1, c_2\\) can re-parametrized \\(0<l_1, l_2\\leq1\\), \\(c_1 = \\max\\{1, l_1\\sqrt{p_1s_1}\\}, c_2 = \\max\\{1, l_2\\sqrt{p_2s_2}\\}\\). Large penalty values correspond features subnetwork, small penalties correspond fewer features. list parameters need specified perform grid search penalty parameters: \\(K\\): Number folds CV. Typically 5-fold CV sufficient. training set contains (e.g. \\(<30\\)) samples, test training set becomes unscalable, choose smaller \\(K\\). \\(CCcoef:\\) Coefficients, \\((a_{,j}, b_{})\\) Equation \\(\\ref{eq:smcca2}\\), weighted SmCCA. can either supplied manually interatively (see code ). \\(PenExpand\\): penalty option matrix \\(X_1, X_2\\). row \\(PenExpand\\) pair penalty options \\(l = (l_1, l_2)\\), \\(0<l_1, l_2<1\\). Larger penalties correspond features included subnetwork. Typically, necessary search entire range (0, 1), smaller grid (e.g. \\(0<l_1, l_2<.5\\)) may sufficient. \\(X\\) list omics data, omics data contain set order subjects. \\(num\\_omics\\) total number omics data \\(X\\). \\(tuneLength\\) total number candidate penalty terms penalty parameter. \\(minTune\\) minimumally possible value penalty parameters. \\(maxTune\\) maximally possible tuning value penalty parameters. SmCCNet K-fold CV. best penalty pairs chosen based smallest total prediction error. code chunks , user plans use 2 omics data, please change code accordingly \\(**\\) marked comment line:","code":"# number of folds in K-fold CV. K <- 3  N <- nrow(X1) # create a list of omics data ** X <- list(X1, X2) # number of omics dataset ** num_omics <- 2 # tuning parameter candidate length for each omics data tuneLength <- 5 # tuning parameter candadate range for each omics data minTune <- 0.1 maxTune <- 0.5 # create empty matrix to store all possible penalty parameters penSelect <- matrix(0, nrow = tuneLength, ncol = num_omics) # create sparsity penalty options. for (Idx in 1:ncol(penSelect)) {   penSelect[,Idx] <- seq(from = minTune,                           to = maxTune,                           length.out = tuneLength) } # expand grid # convert matrix to list of columns list_cols <- as.list(as.data.frame(penSelect)) # generate all possible combinations PenExpand <- do.call(expand.grid, list_cols)  # set a CV directory. CVDir <- \"Example3foldCV/\"  dir.create(CVDir)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"create-test-and-training-data-sets-","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Create test and training data sets.","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"First, need split data (\\(X_1, X_2, Y\\)) test training sets (Figure \\(\\ref{fig:CVflow}\\), Step .1). CCA methods require data sets standardized (centered scaled) columns (e.g. features). included standardization step within SmCCNet algorithm. However, CV procedure, recommend standardize training test sets upfront, since helps choose number CV folds \\(K\\). data set can standardized, recommend reduce \\(K\\). code , show create CV data sets. standardized training test data sets saved “Example3foldCV/” directory.","code":"set.seed(12345) # set random seed.  # split data into folds foldIdx <- suppressWarnings(split(1:nrow(X[[1]]), sample(1:nrow(X[[1]]), K))) folddata <- purrr::map(1:length(foldIdx), function(x){     Y <- as.matrix(Y)     X_train <- list()     X_test <- list()     Y_train <- list()     Y_test <- list()     for (i in 1:length(X))     {       X_train[[i]] <- scale(X[[i]][-foldIdx[[x]],])       X_test[[i]] <- scale(X[[i]][foldIdx[[x]],])     }     Y_train <- scale(Y[-foldIdx[[x]],])     Y_test <- scale(Y[foldIdx[[x]],])     return(list(X_train = X_train, X_test = X_test,Y_train = Y_train,                  Y_test = Y_test)) }) # name each fold of data names(folddata) <- paste0('Fold_', 1:K) # saving all preliminary data into local directory for reproducibility purpose save(folddata, PenExpand,         file = paste0(CVDir, \"CVData.RData\"))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"set-scaling-factors","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Set Scaling Factors","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"important set scaling factors \\(a_{,j}\\)’s \\(b_{}\\)’s pairwise correlation prioritize correlation structure(s) interest. function prompts user define scaling factor intended analysis: default (1,1,1) two omics first line code run. user prefers set scaling factors different ways (1,10,10) 10 set omics-phenotype correlation emphasize omics-phenotype correlation, user can use interactive function . especially effective two omics data used since order pairwise combinations can extremely complicated. Note argument (DataType) interactive function strictly follow order data list used SmCCA computation, followed ‘phenotype’. instance, example data, \\(X_1\\) stands mRNA, \\(X_2\\) stands miRNAs, order argument set (‘mRNA’, ‘miRNA’, ‘phenotype’). example , use \\((1,1,1)\\) scaling factor demonstrate result.","code":"# default scalingFactor <- rep(1,ncol(combn(num_omics + 1,2))) # interactive ** scalingFactor <- scalingFactorInput(DataType = c('mRNA', 'miRNA', 'phenotype'))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"run-k-fold-cv","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Run K-fold CV","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"K-folds, compute prediction error penalty pair option (Figure \\(\\ref{fig:CVflow}\\), Step .2). Since subsampling step cross-validation, run cross-validation nested loop. However, omics data extremely high-dimensional, recommend using R package parallel parallelize loop, use fastAutoSmCCNet() directly. fastAutoSmCCNet() package built-function streamline pipeline single line code, cross-validation step parallelized future_map() furrr package.","code":"# load cross-validation data load(paste0(CVDir, \"CVData.RData\")) # create an empty list for storing CV result for each fold CVResult <- list() for (CVidx in 1:K) {       # set scaling factor     CCcoef <- scalingFactor     # create empty vector for storing cross-validation result     RhoTrain <- RhoTest <- DeltaCor <- rep(0, nrow(PenExpand))     for(idx in 1:nrow(PenExpand))     {       # consider one pair of sparsity penalties at a time.       l <- PenExpand[idx, ]       # run SmCCA on the subsamples (Figure 1, Step II)       Ws <- getCanWeightsMulti(folddata[[CVidx]][[\"X_train\"]],                             Trait = as.matrix(folddata[[CVidx]][[\"Y_train\"]]),                             Lambda = as.numeric(l), NoTrait = FALSE,                             CCcoef = CCcoef)       # evaluate the canonical correlation for training and testing data       rho.train <-  getCanCorMulti(X = folddata[[CVidx]][[\"X_train\"]],                                  Y = as.matrix(folddata[[CVidx]][[\"Y_train\"]]),                                  CCWeight = Ws,                                  CCcoef = CCcoef)       rho.test <-  getCanCorMulti(X = folddata[[CVidx]][[\"X_test\"]],                                  Y = as.matrix(folddata[[CVidx]][[\"Y_test\"]]),                                  CCWeight = Ws,                                  CCcoef = CCcoef)        # store cv result         RhoTrain[idx] <- round(rho.train, digits = 5)       RhoTest[idx] <- round(rho.test, digits = 5)       DeltaCor[idx] <- abs(rho.train - rho.test)          }          # record prediction errors for given CV fold and all sparsity penalty      # options.     CVResult[[CVidx]] <- cbind(RhoTrain, RhoTest, DeltaCor) }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"extract-penalty-pair-with-the-smallest-total-prediction-error","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Extract penalty pair with the smallest total prediction error","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"Finally, extract total prediction errors (Figure \\(\\ref{fig:CVflow}\\), Step .3) conclude best penalty pair grid search pair smallest error (Figure \\(\\ref{fig:CVflow}\\), Step .4). different ways select best penalty terms, one simplest way minimize discrepancy training canonical correlation testing canonical correlation. However, method take magnitude testing canonical correlation account, means may end selecting penalty term smaller canonical correlation (low signal). instance, certain penalty term yields training canonical correlation 0.7, testing canonical correlation 0.4, another penalty term yield training canonical correlation 0.4, testing canonical correlation 0.2, minimizing training testing canonical correlation selects latter. Therefore, step, want minimized scaled prediction error, defined : \\[\\begin{equation} scaledPredErr = \\frac{|trainCC - testCC|}{|testCC|}, \\end{equation}\\] \\(trainCC\\) \\(testCC\\) defined training canonical correlation testing canonical correlation respectively. aggregated cross-validation evaluation result: can visualize scaled prediction errors contour plot (Figure \\(\\ref{fig:contourPlot}\\)), note method works two omics data, two omics data used, please construct contour plot pair omics data respectively. Total scaled prediction error contour plot evaluation metric (defined prediction error/test cc). x- y-axes indicate LASSO penalties considered mRNA miRNA, respectively. Blue yellow scale indicates increasing total scaled prediction error. synthetic data set, optimal penalty pair gives smallest prediction error \\((l_1, l_2) = (0.1, 0.1)\\). Table \\(\\ref{tab:errorTable}\\) shows total prediction error (scaledPredError) penalty options. Note example, including 25 optional penalty pairs. fourth column (RhoTest) records aggregated canonical correlations test data set. Total Prediction Error 3-fold CV synthetic dataset","code":"# aggregate CV result and select the best penalty term AggregatedCVResult <- Reduce(\"+\", CVResult) / length(CVResult) # calculate the evaluation metric of interest EvalMetric <- apply(AggregatedCVResult, 1, function(x) {x[3]/abs(x[2])}) # determine the best CV result optIdx <- which.min(EvalMetric) library(plotly) library(reshape2) f1 <- list(   family = \"Arial, sans-serif\",   size = 20,   color = \"black\" ) f2 <- list(   family = \"Old Standard TT, serif\",   size = 20,   color = \"black\" ) a <- list(   title = \"l1\",   titlefont = f1,   showticklabels = TRUE,   tickfont = f2 ) b <- list(   title = \"l2\",   titlefont = f1,   showticklabels = TRUE,   tickfont = f2 ) # create melt data PenExpandMelt <- cbind(PenExpand[,c(1,2)], EvalMetric) colnames(PenExpandMelt)[c(1,2)] <- c('l1', 'l2') hmelt <- melt(PenExpandMelt, id.vars = c(\"l1\", \"l2\")) contourPlot <- plot_ly(hmelt, x = ~l1, y = ~l2, z = ~value,                         type = \"contour\") %>%   layout(xaxis = a, yaxis = b, showlegend = TRUE, legend = f1)   # orca preinstalltion is required for next step:  # https://github.com/plotly/orca#installation contourPlot # combine CV evaluation result with penalty candidates  overallCVInfo <- cbind(PenExpand, AggregatedCVResult, scaledPredError = EvalMetric) # set column names for penalty terms  colnames(overallCVInfo)[1:num_omics] <- paste0('l',1:num_omics) # save overall CV result  write.csv(overallCVInfo, file = paste0(CVDir, 'overallCVInfo.csv'),            row.names = FALSE) # print out the best CV penalty pair and associated result print(overallCVInfo[optIdx,])"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-iii-run-smcca-with-pre-selected-penalty-term","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset","what":"Step III: Run SmCCA with pre-selected penalty term","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"pre-selected penalty pair, apply SmCCA subsampled features \\(X_1, X_2\\) \\(Y\\), repeat process generate robust similarity matrix (Figure \\(\\ref{fig:flowchart}\\), Step II). number subsamples, larger number subsamples leads accurate results, smaller number subsamples faster computationally. use 50 example. general, recommend subsample 500-1000 times . setup description subsampling parameters: \\(s = (s_1,s_2)\\): Proportions feature subsampling \\(X_1, X_2\\). Default values \\(s_1 = 0.7, s_2 = 0.9.\\) \\(SubsamplingNum\\): Number subsamples. obtaining canonical weight \\(Ws\\), dimension \\(p_1 + p_2\\) (total number features) \\(p_1 s_1 + p_2 s_2\\) (number feature subsamples), next step obtain adjacency matrix taking outer product \\(W\\) obtain adjacency matrix average matrices obtain \\(Abar\\), sparse matrix object (illustrate next section).","code":"# feature sampling proportions, 0.9 for miRNA since it has less features. ** s <- c(0.7,0.9)  # number of subsamples. SubsamplingNum <- 50 # run SmCCA on the subsamples (Figure 1, Step II) Ws <- getRobustWeightsMulti(X,                          Trait = as.matrix(Y),                          NoTrait = FALSE,CCcoef = scalingFactor,                         Lambda = as.numeric(overallCVInfo[optIdx,1:num_omics]),                         s = s,                          SubsamplingNum = SubsamplingNum)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-iv-obtain-multi-omics-modules-through-network-clustering","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset","what":"Step IV: Obtain multi-omics modules through network clustering","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"canonical weights obtained last step, can get multi-omics modules constructing global adjacency matrix applying hierarchical tree cutting plotting reconstructed networks (Figure \\(\\ref{fig:flowchart}\\)). edge signs recovered pairwise feature correlations visualizing network.","code":"# construct adjacency matrix Abar <- getAbar(Ws, FeatureLabel = AbarLabel) # perform clustering based on the adjacency matrix Abar  OmicsModule <- getOmicsModules(Abar, PlotTree = FALSE) save(Ws, Abar, OmicsModule, file = paste0(CVDir, \"SmCCNetWeights.RData\"))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-v-obtain-network-summarization-score-and-pruned-subnetworks","dir":"Articles","previous_headings":"SmCCNet workflow with a synthetic dataset","what":"Step V: Obtain network summarization score and pruned subnetworks","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"next step prune network unnecessary features (nodes) filtered original network module. principle based subject-level score interest known network summarization score. two different network summarization methods: PCA NetSHy (network summarization via hybrid approach, Vu et al 2023 Bioinformatics), specified argument ‘method’. evaluate two criteria stepwise 1) summarization score correlation respect phenotype, used verify summarization score current subnetwork strong signal respect phenotype 2) correlation summarization current subnetwork baseline network pre-defined baseline network size. used check addition molecular features introduces noise. stepwise approach network pruning : following example, summarization used first 3 NetSHy principal components. clustering, 6 network modules, 1 network module 10 nodes. optimal network size network pruning 18. output steps contains network adjacency matrix, summarization scores (first 3 NetSHy PCs), PC loadings , stored .Rdata file user specified location.","code":"# make sure there are no duplicated labels AbarLabel <- make.unique(AbarLabel)  # create concatenate omics data for network pruning X_big <- cbind(X1,X2)  # calculate feature correlation matrix bigCor2 <- cor(X_big)  # data type types <- c(rep('gene', ncol(X1)), rep('mirna', ncol(X2)))  # filter out network modules with insufficient number of nodes module_length <- unlist(lapply(OmicsModule, length)) network_modules <- OmicsModule[module_length > 10] # extract pruned network modules for(i in 1:length(network_modules)) {   cat(paste0('For network module: ', i, '\\n'))   # define subnetwork   abar_sub <- Abar[network_modules[[i]],network_modules[[i]]]   cor_sub <- bigCor2[network_modules[[i]],network_modules[[i]]]   # prune network module   networkPruning(Abar = abar_sub,CorrMatrix = cor_sub,                            type = types[network_modules[[i]]],                   data = X_big[,network_modules[[i]]],                     Pheno = Y, ModuleIdx = i, min_mod_size = 10,                            max_mod_size = 100, method = 'NetSHy',                            saving_dir = CVDir) }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"present network result based synthetic data. first table contains individual molecular features correlation respect phenotype, associated p-value (correlation testing). Individual molecular features correlation table respect phenotype (correlation p-value). PC1 loading subnetwork feature. Correlation heatmap subnetwork features. Adjacency matrix heatmap subnetwork features. Figure \\(\\ref{fig:loadings1}\\) visualization PC loadings contribution molecular features first NetSHy PC. addition, two network heatmaps based (1) correlation matrix (Figure \\(\\ref{fig:corheatmap}\\)), (2) adjacency matrix (Figure \\(\\ref{fig:adjheatmap}\\)). Based summarization table, genes 1,2,6,7, miRNA 2 relatively high correlation respect phenotype. PC loadings also confirm genes 6,7, miRNA 2 generally higher PC contribution. correlation heatmap, observe associations molecular features, adjacency matrix heatmap, observe higher connections genes 6,7 miRNA 2. also recommend experimenting PCs (3) Figure \\(\\ref{fig:loadings1}\\) demonstrate contribution molecular features PC.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-vi-visualize-network-module","dir":"Articles","previous_headings":"Results","what":"Step VI: Visualize network module","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"initial approach network visualization facilitated SmCCNet shinyApp, accessible https://smccnet.shinyapps.io/smccnetnetwork/. Upon obtaining subnetwork file named ‘size_a_net_b.Rdata’, users can upload shinyApp. platform provides various adjustable visualization parameters, enabling users tailor network visualization preferences. alternative way visualize final network module, need download Cytoscape software (Shannon et al., 2003), use package RCy3 visualize subnetwork generated network pruning step. general, since network obtained PageRank pruning algorithm densely connected, edges may false positive (meaning two nodes associated, higher edge values adjacency matrix). Therefore, use correlation matrix filter weak network edges. network visualization (Figure \\(\\ref{fig:netPlot}\\)), different colored edges denote different directions association two nodes, red blue denotes positive negative association respectively. width edge represents connection strength two nodes. Pruned module 1. strength node connections indicated thickness edges. Red edges blue edges negative positive connections respectively. Red node represents genes, blue node represent miRNAs.","code":"library(RCy3) library(igraph) # load subnetwork data (example, user need to provide the directory) load('ResultDirectory/size_a_net_b.Rdata') M <- as.matrix(M) correlation_filter <- 0.05 # correlation matrix filtering for the subnetwork edge-cut filter_index <- which(abs(correlation_sub) < correlation_filter) M_ind <- ifelse(correlation_sub > 0, 1, -1) M_adj <- M * M_ind M_adj[filter_index] <- 0 diag(M_adj) <- 0  # network visualization through cytoscape graph <- igraph::graph_from_adjacency_matrix(M_adj, mode = 'undirected',           weighted = TRUE, diag = TRUE, add.colnames = NULL, add.rownames = NA)  # define network node type and connectivity and use them in cytoscape V(graph)$type <- sub_type V(graph)$type V(graph)$connectivity <- rowSums(abs(M)) V(graph)$connectivity # export subnetwork to Cytoscape  createNetworkFromIgraph(graph,\"multi_omics_network\")"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"methods-for-optimal-scaling-factors-selection","dir":"Articles","previous_headings":"","what":"Methods for Optimal Scaling Factors Selection","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"shown , scaling factors must supplied prioritize correlation structure interest. However, always straightforward determine scaling factors. section , provide 3 different methods select scaling factors interest.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"method-1-use-prompt-to-define-scaling-factors","dir":"Articles","previous_headings":"Methods for Optimal Scaling Factors Selection","what":"Method 1: Use Prompt to Define Scaling Factors","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"common choice scaling factors prioritize omics-phenotype correlation. instance, multi-omics quantitative phenotype analysis 2 omics data, let \\(a_{1,2}\\) scaling factor omics-omics correlation, \\(b_{1}\\) \\(b_{2}\\) scaling factors omics-phenotype correlation, common choice scaling factor \\((a_{1,2},b_1,b_2)\\) \\((1,10,10)\\). can done manual entry interactive function ‘scalingFactorInput()’, example given section 2.2.2.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"method-2-use-automated-smccnet-to-select-scaling-factors-based-on-pairwise-correlation-","dir":"Articles","previous_headings":"Methods for Optimal Scaling Factors Selection","what":"Method 2: Use Automated SmCCNet to Select Scaling Factors Based on Pairwise Correlation.","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"Another method check pairwise correlation pair omics data using sparse canonical correlation analysis (SCCA). ran SCCA stringent penalty pair (\\(0.1,0.1\\)), calculate canonical correlation. canonical correlation calculated treated -omics scaling factor, scaling factor 1 used omics-phenotype relationship. addition, introduced another parameter called shrinkage factor prioritize either omics-omics relationship omics-phenotype relationship. instance, multi-omics analysis two omics data, omics-omics correlation 0.8, shrinkage parameter 2, final scaling factors set \\((,b_1,b_2) = c(0.4, 1, 1)\\). method currently implemented fastAutoSmCCNet(). user want use method, please refer automated SmCCNet vignette.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"method-3-use-cross-validation-to-select-scaling-factors","dir":"Articles","previous_headings":"Methods for Optimal Scaling Factors Selection","what":"Method 3: Use Cross-Validation to Select Scaling Factors","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"Let’s assume two omics data mRNA miRNA quantitative phenotype. want systematically evaluate performance pair scaling factors. best way create candidate scaling factors set setting omics-omics scaling factor 1, varying omics-phenotype scaling factors. make performance comparable, scale set scaling factors sum 1. instance, two omics example, scaling factor \\((a_{1,2}, b_1, b_2)\\) satisfy \\(a_{1,2} + b_1 + b_2 = 1\\). implement nested grid search approach select best scaling factors along corresponding optimal penalty parameters. set scaling factors, sparse penalty parameters (l1, l2) chosen K-fold cross validation find penalty pair minimized scaled prediction error, best scaled prediction error recorded set scaling factors used find optimal scaling factors. penalty pairs set also tested grid search find optimal pair (l1, l2). penalty parameters determine many miRNA (l1) mRNA (l2) final results. Scaling factors grid search evaluated identify value yielded best network results predefined criterion. discuss evaluation criterion section 4.3.2.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"cross-validation-with-each-set-of-scaling-factors","dir":"Articles","previous_headings":"Methods for Optimal Scaling Factors Selection > Method 3: Use Cross-Validation to Select Scaling Factors","what":"Cross validation with each set of scaling factors","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"penalty parameter grid search setup SmCCNet algorithm. Note step section 2.2: , split original data K different folds evaluation: function set searching grid scaling factors. 3 different arguments function: \\(DataType\\): vector omics type annotated (order \\(X\\)), followed ‘phenotype’. \\(tuneLength\\): length candidate scaling factors pairwise combination. \\(tuneRangePheno\\): vector length 2 first argument minimally possible scaling factor value, second argument maximally possible scaling factor value. example , two omics quantitative phenotype, set \\(tuneLength\\) 3, range scaling factor 5 10. Since large number candidate scaling factor pairs, speed cross-validation step, parallel computation can implemented.","code":"# number of folds in K-fold CV. K <- 3  N <- nrow(X1) # create a list of omics data X <- list(X1, X2) # number of omics dataset num_omics <- 2 # tuning parameter candidate length for each omics data tuneLength <- 5 # tuning parameter candadate range for each omics data minTune <- 0.1 maxTune <- 0.5 # create empty matrix to store all possible penalty parameters penSelect <- matrix(0, nrow = tuneLength, ncol = num_omics) # create sparsity penalty options. for (Idx in 1:ncol(penSelect)) {   penSelect[,Idx] <- seq(from = minTune,                           to = maxTune,                           length.out = tuneLength) } # expand grid # convert matrix to list of columns list_cols <- as.list(as.data.frame(penSelect)) # generate all possible combinations PenExpand <- do.call(expand.grid, list_cols)  # set a CV directory. CVDir <- \"Example3foldCVTune/\"  dir.create(CVDir) set.seed(12345) # set random seed.  # split data into folds X <- lapply(X, scale) foldIdx <- suppressWarnings(split(1:nrow(X[[1]]), sample(1:nrow(X[[1]]), K))) folddata <- purrr::map(1:length(foldIdx), function(x){     Y <- as.matrix(Y)     X_train <- list()     X_test <- list()     Y_train <- list()     Y_test <- list()     for (i in 1:length(X))     {       X_train[[i]] <- X[[i]][-foldIdx[[x]],]       X_test[[i]] <- X[[i]][foldIdx[[x]],]     }     Y_train <- Y[-foldIdx[[x]],]     Y_test <- Y[foldIdx[[x]],]     return(list(X_train = X_train, X_test = X_test,Y_train = Y_train,                  Y_test = Y_test)) }) # name each fold of data names(folddata) <- paste0('Fold_', 1:K) # saving all preliminary data into local directory for reproducibility purpose save(folddata, PenExpand,        file = paste0(CVDir, \"CVData.RData\")) # create a function that set up the scaling factor candidate grids gridCCcoef <- function(DataType, tuneLength = 5, tuneRangePheno = c(1,10)) {   # store the length of the data   datalength <- length(DataType)   phenotunelength <- datalength - 1   # create empty matrix for storing the candidate scaling factors   candCoef <- matrix(1, nrow = tuneLength^phenotunelength,                         ncol = ncol(utils::combn(datalength, 2)))   # create storage empty grid   phenoGrids <- matrix(0, nrow = tuneLength,                           ncol = phenotunelength)   # create grids   for (phenoIdx in 1:phenotunelength)   {     phenoGrids[,phenoIdx] <- seq(from = tuneRangePheno[1],                                   to = tuneRangePheno[2],                                   length.out = tuneLength)   }   # expand grid   # convert matrix to list of columns   list_cols <- as.list(as.data.frame(phenoGrids))   # generate combinations   phenoGridsExpand <- do.call(expand.grid, list_cols)   candCoef[,which(utils::combn(datalength,2)[2,] == datalength)] <- as.matrix(     phenoGridsExpand)   # provide column names   colnames(candCoef) <- apply(utils::combn(datalength,2),2, function(x){       paste0(DataType[x[1]],'_', DataType[x[2]])     })   # scale scaling factors so that each set of scaling factors sum up to 1   candCoef <- t(apply(candCoef, 1, function(x) {x/sum(x)}))   return(candCoef)      }  # scaling factor grids CCcoefMatrix <- gridCCcoef(c('mRNA','miRNA', 'pheno'),                             tuneLength = 3, tuneRangePheno = c(5,10))   # create data matrix to store the cross-validation result CVEval <- matrix(0, nrow = nrow(CCcoefMatrix), ncol = num_omics +                     ncol(utils::combn(num_omics + 1, 2)) + 3) CVEval[,1:ncol(utils::combn(num_omics + 1, 2))] <- CCcoefMatrix colnames(CVEval)<- c( paste0('CCcoef:',  colnames(CCcoefMatrix)),                        paste0('l',1:num_omics), \"TrainingCC\", \"TestCC\",                                  \"CCPredError\") for (CCIdx in 1:nrow(CCcoefMatrix)) {   coef <- CCcoefMatrix[CCIdx,]   cat(paste0('Now running SmCCA for the scaling factor candidate ',               CCIdx, '\\n'))    future::plan(future::multisession, workers = K)   CVResult <- furrr::future_map(1:K, function(CVidx) {       # set scaling factor     CCcoef <- coef     # create empty vector for storing cross-validation result     RhoTrain <- RhoTest <- DeltaCor <- rep(0, nrow(PenExpand))     for(idx in 1:nrow(PenExpand))     {       # consider one pair of sparsity penalties at a time.       l <- PenExpand[idx, ]       # run SmCCA on the subsamples (Figure 1, Step II)       Ws <- getCanWeightsMulti(folddata[[CVidx]][[\"X_train\"]],                             Trait = as.matrix(folddata[[CVidx]][[\"Y_train\"]]),                             Lambda = as.numeric(l), NoTrait = FALSE,                             CCcoef = CCcoef)       # evaluate the canonical correlation for training and testing data       rho.train <-  getCanCorMulti(X = folddata[[CVidx]][[\"X_train\"]],                                  Y = as.matrix(folddata[[CVidx]][[\"Y_train\"]]),                                  CCWeight = Ws,                                  CCcoef = CCcoef)       rho.test <-  getCanCorMulti(X = folddata[[CVidx]][[\"X_test\"]],                                  Y = as.matrix(folddata[[CVidx]][[\"Y_test\"]]),                                  CCWeight = Ws,                                  CCcoef = CCcoef)        # store cv result         RhoTrain[idx] <- round(rho.train, digits = 5)       RhoTest[idx] <- round(rho.test, digits = 5)       DeltaCor[idx] <- abs(rho.train - rho.test)          }          # record prediction errors for given CV fold and all sparsity penalty      # options.     DeltaCor.all <- cbind(RhoTrain, RhoTest, DeltaCor)     return(DeltaCor.all)   },.progress = TRUE,.options = furrr::furrr_options(seed = TRUE))   cat('\\n')   # aggregate CV result and select the best penalty term   AggregatedCVResult <- Reduce(\"+\", CVResult) / length(CVResult)   EvalMetric <- apply(AggregatedCVResult, 1, function(x) {x[3]/abs(x[2])})   # determine the best CV result   optIdx <- which.min(EvalMetric)   # fill in the optimal penalty pair for current scaling scaling    # factor selection as well as the evaluation result   CVEval[CCIdx,(ncol(utils::combn(num_omics + 1, 2))+                1):ncol(CVEval)] <- c(as.numeric(PenExpand[optIdx,]),                       as.numeric(AggregatedCVResult[optIdx,]))    # write out the cross-validation result   write.csv(CVEval,              file = paste0(CVDir, \"/PredictionError.csv\"), row.names = FALSE) }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"select-optimal-scaling-factors-with-associated-penalty-parameters","dir":"Articles","previous_headings":"Methods for Optimal Scaling Factors Selection > Method 3: Use Cross-Validation to Select Scaling Factors","what":"Select optimal scaling factors with associated penalty parameters","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"Scaling constants grid search evaluated identify values yielded best network results. define evaluation criterion depends interest study. two omics example, criterion set : \\[\\begin{eqnarray} \\begin{split} \\label{eq:scaling} & (a_{1,2}, b_1, b_2)\\!  =\\! \\arg\\max_{\\tilde a_{1,2}, \\tilde b_1, \\tilde c_2} \\frac{|trainCC - testCC|}{|testCC|}  \\end{split} \\end{eqnarray}\\] selected parameters scaling factors (CCcoef), l1, l2, run SmCCNet entire dataset Session 2.3 identify networks related phenotype interest session 2.4.","code":"# read in the overall cv result evalResult <- read.csv(paste0(CVDir, \"/PredictionError.csv\")) # find the optn evalOptIdx <- which.min(evalResult$CCPredError/abs(evalResult$TestCC)) # print the optimal result  evalResult[evalOptIdx,] # feature sampling proportions, 0.9 for miRNA since it has less features. s <- c(0.7,0.9)  # number of subsamples. SubsamplingNum <- 50 # run SmCCA on the subsamples (Figure 1, Step II) Ws <- getRobustWeightsMulti(X,                          Trait = as.matrix(Y),                          NoTrait = FALSE,                         CCcoef = as.numeric(evalResult[evalOptIdx,                                   1:ncol(utils::combn(num_omics + 1,2))]),                         Lambda = as.numeric(evalResult[evalOptIdx,                                 (ncol(utils::combn(num_omics + 1, 2))                                  +1):(ncol(utils::combn(num_omics +                                   1, 2))+num_omics)]), s = s,                          SubsamplingNum = SubsamplingNum)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"multi-omics-smccnet-with-binary-phenotype","dir":"Articles","previous_headings":"","what":"Multi-Omics SmCCNet with Binary Phenotype","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"SmCCNet workflow overview Binary Phenotype. X1, X2, X3 three omics data types set n subjects. Y indicates Binary phenotype measure n subjects. Note flowchart demonstrate workflow three omics data, also compatible three omics data two omics data. Consider \\(X_1, X_2, ..., X_T\\) \\(T\\) omics datasets, \\(Y\\) phenotype data. general workflow multi-omics SmCCNet binary phenotype follows (Figure \\(\\ref{fig:flowchart-binary}\\)): Run Weighted/Unweighted Sparse Multiple Canonical Correlation Analysis (SmCCA): done \\(X_1, X_2, ..., X_T\\) (excluding phenotype data). output canonical weight vectors (nonzero entries, zero entries filtered) \\(\\tilde W_{t} \\\\mathbb{R}^{p_t^{(sub)} \\times 1}, t = 1,2,...,T\\), represent omics-omics connections. step, filter features connections features, helps reduce dimensionality. Note tend set relaxed penalty terms step include many omics features possible increase performance classifier next step. Subset Omics Data: dataset \\(X_1, X_2, ..., X_T\\) subsetted include omics features selected Step 1, call subsetted data \\(X_t(sub)\\\\mathbb{R}^{n \\times p_{t}^{(sub)}}\\). Concatenate Run Sparse Partial Least Squared Discriminant Analysis (SPLSDA) (Chung Keles, 2010): subsetted datasets \\(X_1(sub), X_2(sub),..., X_T(sub)\\) concatenated \\(X(sub) = [X_1(sub), X_2(sub),...,X_T(sub)] \\\\mathbb{R}^{n\\times p}, p = \\sum_{= 1}^{T} p_i\\). Sparse PLSDA algorithm run extract \\(R\\) latent factors projection matrix, default, \\(R\\) set 3. Projection matrix defined \\(P \\\\mathbb{R}^{p^{(sub)} \\times R}\\). Latent factors defined \\(r = [r_1,r_2,...,r_R] = X(sub) \\cdot P \\\\mathbb{R}^{n \\times R}\\). Aggregate Latent Factors: \\(R\\) latent factors aggregated one using logistic regression, defined logit\\((Y) = \\alpha_1 r_1 + \\alpha_2 r_2 + ... +\\alpha_R r_R\\). Estimate \\(\\alpha\\)’s report performance (e.g., accuracy/AUC score). Feature weights given aggregation projection matrix Sparse PLSDA \\(W_{t}^{*} = P_{t} \\cdot \\alpha \\\\mathbb{R}^{p_t^{(sub)} \\times 1}, t = 1,2,...,T, \\alpha = [\\alpha_1, \\alpha_2,....,\\alpha_r] \\\\mathbb{R}^{R \\times 1}\\), \\(P_{t}\\) subset projection matrix \\(P\\) includes features \\(t\\)th omics data. Normalize Calculate Final Canonical Weight: feature weights \\(W_{1}^{*},W_{2}^{*},...,W_{T}^{*}\\) based sparse PLSDA normalized L2 norm 1. Let \\(\\gamma_1\\) \\(\\gamma_2\\) two scalars representing strength omics-omics omics-phenotype connections, respectively,final canonical weight obtained weighted combining canonical weight step 1 feature weight classifier \\(W_{t} = \\frac{\\gamma_1}{\\gamma_1+\\gamma_2} \\tilde W_{t} + \\frac{\\gamma_2}{\\gamma_1+\\gamma_2} W_{t}^{*}, t = 1,2,...,T\\). Construct Multi-Omics Network Perform Network Pruning: multi-omics network constructed pruned (multi-omics SmCCNet quantitative phenotype). Note Steps 1-3 repeated multiple times different penalty pairs select best pair cross-validation. evaluation metric maximizing classification evaluation metric testing prediction accuracy testing AUC score. Currently 5 different evaluation metrics choose : accuracy, AUC score, precision, recall, F1 score, accuracy default selection. instance, phenotype subject’s disease status possible values 1 (disease-positive) 0 (disease-negative), guidance choose best evaluation metric context:","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"synthetic-dataset-1","dir":"Articles","previous_headings":"Multi-Omics SmCCNet with Binary Phenotype","what":"Synthetic dataset","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"example, consider synthetic data set 500 genes \\((X_1)\\) 100 miRNAs \\((X_2)\\) expression levels measured 358 subjects, along binary phenotype created binarizing quantitative phenotype \\((Y)\\) based median. Denote number features \\(X_1 \\& X_2\\) \\(p_1 \\& p_2\\) respectively, number subjects \\(n\\). Although SmCCNet require normality, calculates Pearson correlation linear combinations omics features phenotype, assumes finite variances finite covariance. necessary include transformation data skewed. algorithm also requires data standardizable (.e. none data matrices include column zero variance.)","code":"data(ExampleData) head(X1[ , 1:6]) ##          Gene_1   Gene_2   Gene_3   Gene_4   Gene_5   Gene_6 ## Samp_1 22.48570 40.35372 31.02575 20.84721 26.69729 30.20545 ## Samp_2 37.05885 34.05223 33.48702 23.53146 26.75463 31.73594 ## Samp_3 20.53077 31.66962 35.18957 20.95254 25.01883 32.15723 ## Samp_4 33.18689 38.48088 18.89710 31.82330 34.04938 38.79989 ## Samp_5 28.96198 41.06049 28.49496 18.37449 30.81524 24.00454 ## Samp_6 18.05983 29.55471 32.54002 29.68452 26.19996 26.76684 head(X2[ , 1:6]) ##           Mir_1    Mir_2    Mir_3    Mir_4    Mir_5     Mir_6 ## Samp_1 15.22391 17.54583 15.78472 14.89198 10.34821  9.689755 ## Samp_2 16.30697 16.67283 13.36153 14.48855 12.66090 11.333613 ## Samp_3 16.54512 16.73501 14.61747 17.84527 13.82279 11.329333 ## Samp_4 13.98690 16.20743 16.29308 17.72529 12.30056  9.844108 ## Samp_5 16.33833 17.39387 16.39792 15.85373 13.38767 10.599414 ## Samp_6 14.54110 16.51999 14.73958 15.87504 13.21359 10.922393 # binarize phenotype variable Y <- ifelse(Y > median(Y), 1, 0) head(Y) ##        Pheno ## Samp_1     0 ## Samp_2     1 ## Samp_3     0 ## Samp_4     1 ## Samp_5     1 ## Samp_6     0 p1 <- ncol(X1) p2 <- ncol(X2) n <- nrow(X1) AbarLabel <- c(colnames(cbind(X1, X2)))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-ii-determine-optimal-sparsity-penalties-through-cross-validation-optional-1","dir":"Articles","previous_headings":"Multi-Omics SmCCNet with Binary Phenotype","what":"Step II: Determine optimal sparsity penalties through cross-validation (optional)","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"parameters set multi-omics quantitative phenotype except extra penalty term evaluate: lasso penalty SPLSDA classifier.","code":"# number of folds in K-fold CV. K <- 3  N <- nrow(X1) # create a list of omics data X <- list(X1, X2) # number of component for PLS ncomp <- 3 # number of omics dataset num_omics <- 2 # tuning parameter candidate length for each omics data tuneLength <- 5 # tuning parameter candadate range for each omics data minTune <- 0.1 maxTune <- 0.5 # create empty matrix to store all possible penalty parameters penSelect <- matrix(0, nrow = tuneLength, ncol = num_omics) # set up the evaluation metric (choose between 'accuracy', 'auc', 'precision', # 'recall', 'f1') metric <- 'auc' # create sparsity penalty options. for (Idx in 1:ncol(penSelect)) {   penSelect[,Idx] <- seq(from = minTune,                           to = maxTune,                           length.out = tuneLength) } # combine with penalty term for classifier penSelect <- cbind(penSelect, seq(from = 0.5,                           to = 0.9,                           length.out = tuneLength)) # expand grid # convert matrix to list of columns list_cols <- as.list(as.data.frame(penSelect)) # generate all possible combinations PenExpand <- do.call(expand.grid, list_cols)  # set a CV directory. CVDir <- \"Example3foldCVBinary/\"  dir.create(CVDir)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"create-test-and-training-data-sets--1","dir":"Articles","previous_headings":"Multi-Omics SmCCNet with Binary Phenotype > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Create test and training data sets.","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":", need split data (\\(X_1, X_2, Y\\)) test training sets (Figure \\(\\ref{fig:CVflow}\\), Step .1). scale complete dataset rather fold increase performance predicting testing phenotype:","code":"set.seed(12345) # set random seed.  # split data into folds X <- lapply(X, scale) foldIdx <- suppressWarnings(split(1:nrow(X[[1]]), sample(1:nrow(X[[1]]), K))) folddata <- purrr::map(1:length(foldIdx), function(x){     Y <- as.matrix(Y)     X_train <- list()     X_test <- list()     Y_train <- list()     Y_test <- list()     for (i in 1:length(X))     {       X_train[[i]] <- X[[i]][-foldIdx[[x]],]       X_test[[i]] <- X[[i]][foldIdx[[x]],]     }     Y_train <- Y[-foldIdx[[x]],]     Y_test <- Y[foldIdx[[x]],]     return(list(X_train = X_train, X_test = X_test,Y_train = Y_train,                  Y_test = Y_test)) }) # name each fold of data names(folddata) <- paste0('Fold_', 1:K) # saving all preliminary data into local directory for reproducibility purpose save(folddata, PenExpand,        file = paste0(CVDir, \"CVData.RData\"))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"set-scaling-factors-1","dir":"Articles","previous_headings":"Multi-Omics SmCCNet with Binary Phenotype > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Set Scaling Factors","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"important set scaling factors pairwise correlation prioritize correlation structure(s) interest. two omics data used, one scaling factor -omics canonical correlation analysis, natural set scaling factor 1: two omics data used, function use prompt help user define scaling factor intended analysis, note different quantitative phenotype, phenotype excluded scaling factor input:","code":"scalingFactor <- 1 scalingFactor <- scalingFactorInput(c('mRNA', 'miRNA'))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"run-k-fold-cv-1","dir":"Articles","previous_headings":"Multi-Omics SmCCNet with Binary Phenotype > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Run K-fold CV","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"multi-omics quantitative phenotype, cross-validation run determine best penalty terms combinations. difference since predictive modeling problem, evaluation metric used based testing data, comparison training testing. example , use testing AUC score evaluate model performance.","code":"# create an empty list to store the cv result  CVResult <- list() # load cross-validation data load(paste0(CVDir, \"CVData.RData\")) for (CVidx in 1:K) {     CCcoef <- scalingFactor   TrainScore <- TestScore <- rep(0, nrow(PenExpand))   for(idx in 1:nrow(PenExpand)){     # consider one pair of sparsity penalties at a time.     l <- PenExpand[idx, ]     # run multi-block PLS     CCcoef <- scalingFactor     # run multi-block PLS     suppressMessages(projection <- getRobustWeightsMultiBinary(                                    folddata[[CVidx]][[\"X_train\"]],                                     as.numeric(folddata[[CVidx]][[\"Y_train\"]]),                                     SubsamplingPercent=c(1,1),                                    Between_Discriminate_Ratio = c(1,1),                                    LambdaBetween = l[1,1:num_omics],                                     LambdaPheno = l[1,(num_omics + 1)],                                     SubsamplingNum = 1,                                     CCcoef = CCcoef,                                    ncomp_pls = ncomp, EvalClassifier = TRUE,                                    testData = folddata[[CVidx]][[\"X_test\"]]))                          # create training and testing data, and fit logistic regression model     train_data <- data.frame(x = projection[[1]],                               y = as.factor(folddata[[CVidx]][[\"Y_train\"]]))     test_data <- data.frame(x =  projection[[2]])      # catching error when performing the logistic regression     has_error <- FALSE     suppressWarnings(     tryCatch({         # fit logistic regression model         logisticFit <- stats::glm(y ~ ., family = 'binomial', data = train_data)         # make prediction for train/test set         train_pred <- stats::predict(logisticFit, train_data, type = 'response')         test_pred <- stats::predict(logisticFit, test_data, type = 'response')         train_score <- classifierEval(obs = folddata[[CVidx]][[\"Y_train\"]],                                        pred = train_pred,                                        EvalMethod = metric, print_score = FALSE)         test_score <- classifierEval(obs = folddata[[CVidx]][[\"Y_test\"]],                                        pred = test_pred,                                        EvalMethod = metric, print_score = FALSE)           },         error = function(e) {           cat(\"Caught an error:\", e$message, \"\\n\")           has_error <- TRUE         })         )                    TrainScore[idx] <- round(train_score, digits = 5)         TestScore[idx] <- round(test_score, digits = 5)           }          # record prediction errors for given CV fold and all sparsity penalty      # options.     CVResult[[CVidx]] <- cbind(TrainScore, TestScore) }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"extract-penalty-terms-with-the-highest-testing-evaluation-score","dir":"Articles","previous_headings":"Multi-Omics SmCCNet with Binary Phenotype > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Extract penalty terms with the highest testing evaluation score","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"Finally, extract total prediction score conclude best penalty pair pair highest prediction score (example’s context, AUC score). last step, store aggregated cross-validation result local directory:","code":"# aggregate CV result and select the best penalty term AggregatedCVResult <- Reduce(\"+\", CVResult) / length(CVResult) # determine the best CV result optIdx <- which.max(AggregatedCVResult[,2]) # combine CV evaluation result with penalty candidates  overallCVInfo <- cbind(PenExpand, AggregatedCVResult) # set column names for penalty terms for omics colnames(overallCVInfo)[1:num_omics] <- paste0('l',1:num_omics) # set column names for penalty terms for classifier colnames(overallCVInfo)[num_omics+1] <- paste0('lpheno') # save overall CV result  write.csv(overallCVInfo, file = paste0(CVDir, 'overallCVInfo.csv'),            row.names = FALSE) # print out the best CV penalty pair and associated result print(overallCVInfo[optIdx,])"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"step-iii-run-splsda-with-pre-selected-penalty-terms","dir":"Articles","previous_headings":"Multi-Omics SmCCNet with Binary Phenotype","what":"Step III: Run SPLSDA with pre-selected penalty terms","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":", pre-selected penalty pair, apply method subsampled features \\(X_1, X_2\\) \\(Y\\), repeat process generate robust similarity matrix. Note addition subsampling, need add -discriminant ratio (defined \\(\\gamma_1/\\gamma_2\\)) control trade-omics-omics relationship omics-phenotype relationship presented subsequent adjacency matrix. larger second number , emphasize omics-phenotype correlation, vice versa. rest network analysis step multi-omics SmCCNet quantitative phenotype, please refer section 2.3 2.4 information. Note since cross-validation penalty terms evaluation binary phenotype doesn’t involve participation canonical weight step 1, need tune scaling factors method 3 section 4.3. However, method 1 2 (section 4.1 4.2) can used determine scaling factors -omics relationship 2 omics data.","code":"# feature sampling proportions, 0.9 for miRNA since it has less features. s <- c(0.7,0.9)  # number of subsamples. SubsamplingNum <- 50 # run SPLSDA on the subsamples Ws <- getRobustWeightsMultiBinary(X,              as.numeric(Y),              SubsamplingPercent=s,             Between_Discriminate_Ratio = c(1,1),             LambdaBetween = as.numeric(overallCVInfo[optIdx,1:num_omics]),              LambdaPheno = as.numeric(overallCVInfo[optIdx,num_omics + 1]),              SubsamplingNum = SubsamplingNum,              CCcoef = scalingFactor,             ncomp_pls = ncomp, EvalClassifier = FALSE)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"like acknowledge original contributors SmCCNet R package, including Yonghua Zhuang, W. Jenny Shi, Laura Saba. collective contributions earlier versions SmCCNet instrumental shaping development. also deeply grateful Dr.Katerina Kechris, continuous guidance support, vital refinement package. SmCCNet R package owes much growth functionality original contributors, appreciate enduring influence development.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"","code":"sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] grid      stats     graphics  grDevices utils     datasets  methods   ## [8] base      ##  ## other attached packages: ##  [1] reshape2_1.4.4   shadowtext_0.1.2 lubridate_1.9.3  forcats_1.0.0    ##  [5] stringr_1.5.1    dplyr_1.1.4      purrr_1.0.2      readr_2.1.5      ##  [9] tidyr_1.3.0      tibble_3.2.1     ggplot2_3.4.4    tidyverse_2.0.0  ## [13] SmCCNet_2.0.2    furrr_0.3.1      future_1.33.1    igraph_1.6.0     ## [17] Matrix_1.6-1.1   pbapply_1.7-2    ##  ## loaded via a namespace (and not attached): ##  [1] gtable_0.3.4      xfun_0.41         bslib_0.6.1       lattice_0.21-9    ##  [5] tzdb_0.4.0        vctrs_0.6.5       tools_4.3.2       generics_0.1.3    ##  [9] parallel_4.3.2    fansi_1.0.6       highr_0.10        pkgconfig_2.0.3   ## [13] desc_1.4.3        lifecycle_1.0.4   farver_2.1.1      compiler_4.3.2    ## [17] textshaping_0.3.7 munsell_0.5.0     codetools_0.2-19  htmltools_0.5.7   ## [21] sass_0.4.8        yaml_2.3.8        pillar_1.9.0      pkgdown_2.0.7     ## [25] jquerylib_0.1.4   cachem_1.0.8      parallelly_1.36.0 tidyselect_1.2.0  ## [29] digest_0.6.34     stringi_1.8.3     listenv_0.9.0     labeling_0.4.3    ## [33] fastmap_1.1.1     colorspace_2.1-0  cli_3.6.2         magrittr_2.0.3    ## [37] utf8_1.2.4        withr_2.5.2       scales_1.3.0      timechange_0.2.0  ## [41] rmarkdown_2.25    globals_0.16.2    ragg_1.2.7        hms_1.1.3         ## [45] memoise_2.0.1     evaluate_0.23     knitr_1.45        rlang_1.1.3       ## [49] Rcpp_1.0.12       glue_1.7.0        jsonlite_1.8.8    R6_2.5.1          ## [53] plyr_1.8.9        systemfonts_1.0.5 fs_1.6.3 warnings()"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_MultiOmics.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Reconstructing Phenotype-Specific Multi-Omics Networks with SmCCNet","text":"Chung D Keles S (2010), “Sparse partial least squares classification high dimensional data”, Statistical Applications Genetics Molecular Biology, Vol. 9, Article 17. Shi, W.J., Y. Zhuang, P.H. Russell, B.D. Hobbs, M.M. Parker,P.J. Castaldi, P. Rudra, B. Vestal, C.P. Hersh, L.M. Saba, K. Kechris, “Unsupervised Discovery Phenotype Specific Multi-Omics Networks.” Bioinformatics. 2019 Nov 1;35(21):4336-4343. doi: 10.1093/bioinformatics/btz226. Shannon, P., Markiel, ., Ozier, O., Baliga, N. S., Wang, J. T., Ramage, D., … & Ideker, T. (2003). Cytoscape: software environment integrated models biomolecular interaction networks. Genome research, 13(11), 2498-2504. Vu, T., Litkowski, E. M., Liu, W., Pratte, K. ., Lange, L., Bowler, R. P., … & Kechris, K. J. (2023). NetSHy: network summarization via hybrid approach leveraging topological properties. Bioinformatics, 39(1), btac818.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"smccnet-package","dir":"Articles","previous_headings":"","what":"SmCCNet package","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"SmCCNet package following dependencies: section provides tutorial running SmCCNet algorithm quantitative phenotype using single-omics data. Please see vignettes multi-omics applications.","code":"library(pbapply) library(Matrix) library(igraph) library(SmCCNet) library(parallel)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"smccnet-single-omics-workflow-with-a-synthetic-dataset","dir":"Articles","previous_headings":"","what":"SmCCNet single-omics workflow with a synthetic dataset","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"Workflow SmCCNet single-omics setting (binary quantitative phenotype). example, consider synthetic data set 500 genes \\((X_1)\\) expression levels measured 358 subjects, along quantitative phenotype \\((Y)\\). example single phenotype, multi-dimensional phenotype matrix also possible. Denote number features \\(X_1\\) \\(p_1\\) number subjects \\(n\\).","code":"data(ExampleData) head(X1[ , 1:6]) ##          Gene_1   Gene_2   Gene_3   Gene_4   Gene_5   Gene_6 ## Samp_1 22.48570 40.35372 31.02575 20.84721 26.69729 30.20545 ## Samp_2 37.05885 34.05223 33.48702 23.53146 26.75463 31.73594 ## Samp_3 20.53077 31.66962 35.18957 20.95254 25.01883 32.15723 ## Samp_4 33.18689 38.48088 18.89710 31.82330 34.04938 38.79989 ## Samp_5 28.96198 41.06049 28.49496 18.37449 30.81524 24.00454 ## Samp_6 18.05983 29.55471 32.54002 29.68452 26.19996 26.76684 head(Y) ##           Pheno ## Samp_1 235.0674 ## Samp_2 253.5450 ## Samp_3 234.2050 ## Samp_4 281.0354 ## Samp_5 245.4478 ## Samp_6 189.6231 p1 <- ncol(X1) N <- nrow(X1) AbarLabel <- colnames(X1)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-i--preprocessing","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset","what":"Step I. Preprocessing","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"first step preprocess single omics data. canonical correlation analysis (CCA) methods require data sets standardized (centered scaled) columns (e.g. features) ensure equivalent contribution feature maximizing covariance. addition, optional steps preprocess data. Note employing standardization covariate adjustment, essential apply standardization prior covariate adjustment. sequencing ensures best efforts meet assumptions linear regression data preprocessing pipeline, following options given (ordering): 1. CoV Filtering: Filter features based coefficients variation (CoV). 2. Standardization: Center /scale data. 3. Adjust Covariates: Regress specified covariates return residuals example data preprocessing feature filtering standardization, case, covariate adjustment, coeffcient variation filtering quantile 0.2 (meaning features CoV smaller 20% quantile CoV filtered ), data centered scaled:","code":"# preprocess data processed_data <- dataPreprocess(X = as.data.frame(X1), covariates = NULL,                    is_cv = TRUE, cv_quantile = 0.2, center = TRUE, scale = TRUE)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-ii-determine-optimal-sparsity-penalties-through-cross-validation-optional","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset","what":"Step II: Determine optimal sparsity penalties through cross-validation (optional)","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"find optimal sparsity penalties, apply K-fold cross-validation synthetic data (Figure 1). Let \\(p_1\\) denote number features omics data \\(X_1\\) respectively, \\(s_1\\) proportion \\(X_1\\) features sampled every time. sparse penalties range 0.05 0.3 step size 0.05. Large penalty values correspond less sparse canonical weight vector, small penalties correspond sparser canonical weight vector. list parameters need specified: \\(K\\): Number folds cross-validation (CV). Typically 5-fold CV sufficient. training set contains (e.g. \\(<30\\)) samples, test training set becomes unscalable, choose smaller \\(K\\).","code":"K <- 3 # number of folds in K-fold CV. s1 <- 0.7 subSamp <- 50 # number of subsamples (will be described in later section).  # create sparsity penalty options. pen1 <- seq(.05, .3, by = .05)  # set a CV directory. CVDir <- \"Example3foldCV/\"  pheno <- \"Example3foldCV\" dir.create(CVDir)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"create-test-and-training-data-sets-","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Create test and training data sets.","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"perform K-fold Cross-Validation (CV), need split data (\\(X_1, Y\\)) test training sets. included standardization step within SmCCNet algorithm. However, CV procedure, recommend standardize training test sets upfront, since helps choose number CV folds \\(K\\). data set can standardized, recommend reduce \\(K\\). code , show create CV data sets check data sets valid (.e. standardizable). standardized training test data sets saved CV directory.","code":"# set random seed set.seed(12345)   # save data and parameters into local directory save(X1, Y, s1, subSamp, pen1,       file = paste0(CVDir, \"Data.Rdata\"))  # split data into K folds foldIdx <- split(1:N, sample(1:N, K)) for(i in 1:K){   iIdx <- foldIdx[[i]]   x1.train <- scale(X1[-iIdx, ])   yy.train <- Y[-iIdx, ]   x1.test <- scale(X1[iIdx, ])   yy.test <- Y[iIdx, ]      if(is.na(min(min(x1.train), min(yy.train), min(x1.test), min(yy.test)))){     stop(\"Invalid scaled data.\")   }      subD <- paste0(CVDir, \"CV_\", i, \"/\")   dir.create(subD)    # save data from each fold into local directory   save(x1.train, yy.train, x1.test, yy.test,        pen1, p1,         file = paste0(subD, \"Data.Rdata\")) }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"run-k-fold-cross-validation","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Run K-fold Cross-Validation","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"K-folds, compute prediction error penalty pair option. Since subsampling step cross-validation, run cross-validation nested loop. However, omics data extremely high-dimensional, recommend using R package parallel parallelize loop, use fastAutoSmCCNet() directly. fastAutoSmCCNet() package built-function streamline pipeline single line code, cross-validation step parallelized future_map() furrr package.","code":"# number of clusters in parSapply should be the same as number specified above suppressWarnings(for (CVidx in 1:K) {   # define the sub-directory for each fold    subD <- paste0(CVDir, \"CV_\", CVidx, \"/\")   # load fold data   load(paste0(subD, \"Data.Rdata\"))   dir.create(paste0(subD, \"SmCCA/\"))   # create empty vector to store cross-validation result   RhoTrain <- RhoTest <- DeltaCor <- rep(0, length(pen1))   # evaluate through all the possible penalty candidates   for(idx in 1:length(pen1)){     l1 <- pen1[idx]     print(paste0(\"Running SmCCA on CV_\", CVidx, \" pen=\", l1))     # run single-omics SmCCNet     Ws <- getRobustWeightsSingle(x1.train, as.matrix(yy.train), l1, 1,                                     SubsamplingNum = 1)     # average     meanW <- rowMeans(Ws)     v <- meanW[1:p1]          rho.train <-  cor(x1.train %*% v, yy.train)               rho.test <- cor(x1.test %*% v, yy.test)                RhoTrain[idx] <- round(rho.train, digits = 5)     RhoTest[idx] <- round(rho.test, digits = 5)     DeltaCor[idx] <- abs(rho.train - rho.test)                 }      DeltaCor.all <- cbind(pen1, RhoTrain, RhoTest, DeltaCor)   colnames(DeltaCor.all) <- c(\"l1\", \"Training CC\", \"Test CC\", \"CC Pred. Error\")   write.csv(DeltaCor.all,             file = paste0(subD, \"SmCCA/SCCA_\", subSamp,\"_allDeltaCor.csv\"))       })"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"extract-penalty-term-with-the-smallest-total-prediction-error","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset > Step II: Determine optimal sparsity penalties through cross-validation (optional)","what":"Extract penalty term with the smallest total prediction error","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"extract total prediction errors return best penalty term. step automatically give optimal testing canonical correlation choice well prediction error choice, serves reference penalty term selection. different ways select best penalty terms, one simplest way minimize discrepancy training canonical correlation testing canonical correlation. However, method take magnitude testing canonical correlation account, means may end selecting penalty term smaller canonical correlation (low signal). instance, certain penalty term yields training canonical correlation 0.7, testing canonical correlation 0.4, another penalty term yield training canonical correlation 0.4, testing canonical correlation 0.2, minimizing training testing canonical correlation selects latter. Therefore, step, want minimized scaled prediction error, defined : \\[\\begin{equation} scaledPredErr = \\frac{|trainCC - testCC|}{|testCC|}, \\end{equation}\\] \\(trainCC\\) \\(testCC\\) defined training canonical correlation testing canonical correlation respectively.","code":"# combine prediction errors from all K folds and compute the total prediction # error for each sparsity penalty pair. aggregateCVSingle(CVDir, \"SmCCA\", NumSubsamp = subSamp, K = K)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-iii-run-smcca-with-pre-selected-penalty-term","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset","what":"Step III: Run SmCCA with pre-selected penalty term","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"pre-selected penalty term, apply SmCCA subsampled features \\(X_1\\) \\(Y\\), repeat process generate robust similarity matrix (Figure 1). number subsample, larger number subsamples leads stable results, smaller number subsample faster computationally. use 50 example. setup description subsampling parameters: \\(s1\\): Proportions feature subsampling \\(X_1, X_2\\). Default values \\(s_1 = 0.7, s_2 = 0.9.\\) \\(SubsamplingNum\\): Number subsamples. obtaining canonical weight \\(Ws\\), dimension \\(p_1\\) (number features) \\(p_1 s_1\\) (proportion feature subsamples), next step obtain adjacency matrix taking outer product \\(W\\) obtain adjacency matrix average matrices obtain \\(Abar\\), sparse matrix object.","code":"# set up directory to store all the results plotD <- paste0(CVDir, \"Figures/\") saveD <- paste0(CVDir, \"Results/\") dataF <- paste0(CVDir, \"Data.Rdata\") dir.create(plotD) dir.create(saveD) dir.create(dataF)  # type of CCA result, only \"SmCCA\" supported Method = \"SmCCA\"   # after SmCCA CV, select the best penalty term,  # and use it for running SmCCA on the complete dataset for(Method in \"SmCCA\"){   # select optimal penalty term from CV result   T12 <- read.csv(paste0(CVDir, \"Results/\", Method, \"CVmeanDeltaCors.csv\"))   # calculate evaluation metric **   pen <- T12[which.min(T12[ ,4]/abs(T12[ ,3])) ,2]         l1 <- pen;   system.time({     Ws <- getRobustWeightsSingle(X1 = X1, Trait = as.matrix(Y),                                         Lambda1 = l1,                                         s1, SubsamplingNum = subSamp)               Abar <- getAbar(Ws, FeatureLabel = AbarLabel[1:p1])     save(l1, X1, Y, s1, Ws, Abar,          file = paste0(saveD, Method, K, \"foldSamp\", subSamp, \"_\", pen,                         \".Rdata\"))   })       }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-iv-obtain-single-omics-modules-through-network-clustering","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset","what":"Step IV: Obtain single-omics modules through network clustering","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"similarity matrix obtained last step, obtain single-omics modules applying hierarchical tree cutting plotting reconstructed networks. edge signs recovered pairwise feature correlations.","code":"# perform clustering based on the adjacency matrix Abar  OmicsModule <- getOmicsModules(Abar, PlotTree = FALSE)  # make sure there are no duplicated labels AbarLabel <- make.unique(AbarLabel)  # calculate feature correlation matrix bigCor2 <- cor(X1)  # data type types <- rep('gene', nrow(bigCor2))"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-v-obtain-network-summarization-score-and-pruned-subnetworks","dir":"Articles","previous_headings":"SmCCNet single-omics workflow with a synthetic dataset","what":"Step V: Obtain network summarization score and pruned subnetworks","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"next step prune network unnecessary features (nodes) filtered original network module. principle based subject-level score interest known network summarization score. two different network summarization methods: PCA NetSHy (network summarization via hybrid approach, Vu et al 2023 Bioinformatics), specified argument ‘method’. evaluate two criteria stepwise 1) summarization score correlation respect phenotype, used verify summarization score current subnetwork strong signal respect phenotype 2) correlation summarization current subnetwork baseline network pre-defined baseline network size. used check addition molecular features introduces noise. stepwise approach network pruning : Users can prune network module obtained hierarchical clustering following code: output step contains network adjacency matrix, summarization scores (first 3 PCs), PC loadings , stored .Rdata file user-specified location.","code":"# filter out network modules with insufficient number of nodes module_length <- unlist(lapply(OmicsModule, length)) network_modules <- OmicsModule[module_length > 10] # extract pruned network modules for(i in 1:length(network_modules)) {   cat(paste0('For network module: ', i, '\\n'))   # define subnetwork   abar_sub <- Abar[network_modules[[i]],network_modules[[i]]]   cor_sub <- bigCor2[network_modules[[i]],network_modules[[i]]]   # prune network module   networkPruning(Abar = abar_sub,CorrMatrix = cor_sub,                            type = types[network_modules[[i]]],                   data = X1[,network_modules[[i]]],                     Pheno = Y, ModuleIdx = i, min_mod_size = 10,                            max_mod_size = 100, method = 'PCA',                            saving_dir = getwd())   cat(\"\\n\") }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"present single-omics network result based synthetic data. first table contains individual molecular features correlation respect phenotype, associated p-value (correlation testing). Individual molecular features correlation table respect phenotype (correlation p-value). PC1 loading subnetwork feature. Correlation heatmap subnetwork features. Adjacency matrix heatmap subnetwork features. Figure \\(\\ref{fig:loadings1}\\) visualization PC loadings represents contribution molecular features first NetSHy PC. addition, two network heatmaps based (1) correlation matrix (Figure \\(\\ref{fig:corheatmap}\\)), (2) adjacency matrix (Figure \\(\\ref{fig:adjheatmap}\\)). Based summarization table, genes 1,2,6, 7 relatively high correlation respect phenotype. PC loadings also confirm genes 1,2,5,6,7 generally PC contribution. correlation heatmap, observe associations molecular features, adjacency matrix heatmap, observe higher connections genes 1,2,6, 7.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-vi-visualize-network-module","dir":"Articles","previous_headings":"Results","what":"Step VI: Visualize network module","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"initial approach network visualization facilitated SmCCNet shinyApp, accessible https://smccnet.shinyapps.io/smccnetnetwork/. Upon obtaining subnetwork file named ‘size_a_net_b.Rdata’, users can upload shinyApp. platform provides various adjustable visualization parameters, enabling users tailor network visualization preferences. alternative way visualize final network module, need download Cytoscape software, use package RCy3 visualize subnetwork generated network trimming step. general, since network obtained PageRank trimming algorithm densely connected, edges may false positive (meaning two nodes associated, higher edge values adjacency matrix). Therefore, use correlation matrix filter weak network edges. network visualization (Figure \\(\\ref{fig:netPlot}\\)), different colored edges denote different directions association two nodes, red blue denotes positive negative association respectively. width edge represents connection strength two nodes. Trimmed module 1. strength node connections indicated thickness edges. Red edges blue edges negative positive connections respectively.","code":"library(RCy3) library(igraph) # load subnetwork data (example, user need to provide the directory) load('ResultDirectory/size_a_net_b.Rdata') M <- as.matrix(M)  # correlation matrix for the subnetwork filter_index <- which(abs(correlation_sub) < 0.05) M_ind <- ifelse(correlation_sub > 0, 1, -1) M_adj <- M * M_ind M_adj[filter_index] <- 0 diag(M_adj) <- 0  # network visualization through cytoscape graph <- igraph::graph_from_adjacency_matrix(M_adj, mode = 'undirected',           weighted = TRUE, diag = TRUE, add.colnames = NULL, add.rownames = NA)  # define network node type and connectivity V(graph)$type <- sub_type V(graph)$type V(graph)$connectivity <- rowSums(abs(M)) V(graph)$connectivity  createNetworkFromIgraph(graph,\"single_omics_network\")"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"single-omics-smccnet-for-binary-phenotype","dir":"Articles","previous_headings":"","what":"Single-omics SmCCNet for Binary Phenotype","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"section provides tutorial running SmCCNet algorithm binary phenotype using single-omics data. Given binary nature phenotype, canonical correlation analysis can applied, may pose challenges due correlation issues binary random variables. address , employ Sparse Partial Least Squares Discriminant Analysis (SPLSDA) modify SmCCNet algorithm binary phenotype. SPLSDA operates dual-stage approach aimed predicting phenotype. Initially, treats binary phenotype quantitative variable applies partial least squares derive multiple latent factors. Subsequently, latent factors used predict binary phenotype using logistic regression. latent factors consolidated single factor based logistic regression coefficient. Similar sparse multiple canonical correlation analysis (SmCCA) used quantitative phenotype analysis SmCCNet, sparsity parameter needs tuned. However, SPLSDA, increase penalty value results higher level sparsity, contrary CCA-based method implemented package. ’s also important note algorithm designed specifically binary phenotypes. users dealing multi-class phenotypes, one-versus-approach can used generate networks separately multi-class phenotype ordinal. Alternatively, multi-class phenotype ordinal, CCA-based approach can applied.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"import-synthetic-dataset-with-binary-phenotype","dir":"Articles","previous_headings":"Single-omics SmCCNet for Binary Phenotype","what":"Import synthetic dataset with binary phenotype","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"example, consider synthetic data set 500 genes \\((X_1)\\) expression levels measured 358 subjects, along binarized phenotype \\((Y)\\) taking median original phenotype cutoff, transforming binary variable. Denote number features \\(X_1\\) \\(p_1\\), number subjects \\(n\\). parameter setup approach mirrors SmCCA, specific information, please refer back single-omics quantitative phenotype section 1.","code":"data(ExampleData) head(X1[ , 1:6]) ##          Gene_1   Gene_2   Gene_3   Gene_4   Gene_5   Gene_6 ## Samp_1 22.48570 40.35372 31.02575 20.84721 26.69729 30.20545 ## Samp_2 37.05885 34.05223 33.48702 23.53146 26.75463 31.73594 ## Samp_3 20.53077 31.66962 35.18957 20.95254 25.01883 32.15723 ## Samp_4 33.18689 38.48088 18.89710 31.82330 34.04938 38.79989 ## Samp_5 28.96198 41.06049 28.49496 18.37449 30.81524 24.00454 ## Samp_6 18.05983 29.55471 32.54002 29.68452 26.19996 26.76684 head(Y) ##           Pheno ## Samp_1 235.0674 ## Samp_2 253.5450 ## Samp_3 234.2050 ## Samp_4 281.0354 ## Samp_5 245.4478 ## Samp_6 189.6231 # binarize quantitative outcome  Y <- ifelse(Y > median(Y), 1, 0) p1 <- ncol(X1) N <- nrow(X1) AbarLabel <- colnames(X1) K <- 3 # number of folds in K-fold CV. s1 <- 0.7 # feature subsampling percentage. subSamp <- 50 # number of subsamples. CCcoef <- NULL # unweighted version of SmCCNet. metric <- 'auc' # evaluation metric to be used.  # create sparsity penalty options. pen1 <- seq(.1, .9, by = .1)  # set a CV directory. CVDir <- \"Example3foldCV_Binary/\"  pheno <- \"Example3foldCV_Binary\" dir.create(CVDir)  Y <- ifelse(Y > median(Y), 1, 0)"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-ii-determine-optimal-sparsity-penalty-through-cross-validation-optional","dir":"Articles","previous_headings":"Single-omics SmCCNet for Binary Phenotype","what":"Step II: Determine optimal sparsity penalty through cross-validation (optional)","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"SPLS package include method assessing prediction accuracy. Therefore, utilize glm() function stats package evaluate performance model. Particularly SPLSDA, number components important factor consider goal make predictions. following example, select three number components. procedures remain identical SmCCA (see single-omics quantitative phenotype vignette).","code":"set.seed(12345) # set random seed. # save original data into local directory save(X1, Y, s1, subSamp, pen1,       file = paste0(CVDir, \"Data.Rdata\"))   # define the number of components to be extracted ncomp <- 3 # split data into k folds foldIdx <- split(1:N, sample(1:N, K)) for(i in 1:K){   iIdx <- foldIdx[[i]]   x1.train <- scale(X1[-iIdx, ])   yy.train <- Y[-iIdx, ]   x1.test <- scale(X1[iIdx, ])   yy.test <- Y[iIdx, ]      if(is.na(min(min(x1.train), min(yy.train), min(x1.test), min(yy.test)))){     stop(\"Invalid scaled data.\")   }      subD <- paste0(CVDir, \"CV_\", i, \"/\")   dir.create(subD)   save(x1.train, yy.train, x1.test, yy.test,       pen1, p1,         file = paste0(subD, \"Data.Rdata\")) }  ############################################## Running Cross-Validation  # run SmCCA with K-fold cross-validation suppressWarnings(for (CVidx in 1:K){   # define evaluation method   EvalMethod <- 'precision'   # define and create saving directory   subD <- paste0(CVDir, \"CV_\", CVidx, \"/\")   load(paste0(subD, \"Data.Rdata\"))   dir.create(paste0(subD, \"SmCCA/\"))    # create empty vector to store cross-validation accuracy result   TrainScore <- TestScore <- rep(0, length(pen1))   for(idx in 1:length(pen1)){     # define value of penalty     l1 <- pen1[idx]      # run SPLS-DA to extract canonical weight     Ws <- spls::splsda(x = x1.train, y = yy.train, K = ncomp, eta = l1,                         kappa=0.5,                        classifier= 'logistic', scale.x=FALSE)      # create emtpy matrix to save canonical weights for each subsampling     weight <- matrix(0,nrow = ncol(x1.train), ncol = ncomp)     weight[Ws[[\"A\"]],] <- Ws[[\"W\"]]      # train the latent factor model with logistic regression     train_data <- data.frame(x = (x1.train %*% weight)[,1:ncomp],                               y = as.factor(yy.train))     test_data <- data.frame(x = (x1.test %*% weight)[,1:ncomp])          logisticFit <- stats::glm(y~., family = 'binomial',data = train_data)     # make prediction for train/test set     train_pred <- stats::predict(logisticFit, train_data, type = 'response')     test_pred <- stats::predict(logisticFit, test_data, type = 'response')     # specifying which method to use as evaluation metric     TrainScore[idx] <- classifierEval(obs = yy.train,                                        pred = train_pred,                                        EvalMethod = metric, print_score = FALSE)     TestScore[idx] <- classifierEval(obs = yy.test,                                        pred = test_pred,                                        EvalMethod = metric, print_score = FALSE)        }    # combine cross-validation results   DeltaAcc.all <- as.data.frame(cbind(pen1, TrainScore, TestScore))   DeltaAcc.all$Delta <- abs(DeltaAcc.all$TrainScore - DeltaAcc.all$TestScore)   colnames(DeltaAcc.all) <- c(\"l1\", \"Training Score\", \"Testing Score\", \"Delta\")      # save cross-validation results to local directory   write.csv(DeltaAcc.all,             file = paste0(subD, \"SmCCA/SCCA_\", subSamp,\"_allDeltaCor.csv\"))    } )"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"step-iii-run-splsda-with-pre-selected-penalty-term","dir":"Articles","previous_headings":"Single-omics SmCCNet for Binary Phenotype","what":"Step III: Run SPLSDA with pre-selected penalty term","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"evaluation metric maximizing classification evaluation metric testing prediction accuracy testing AUC score. Currently 5 different evaluation metrics choose : accuracy, AUC score, precision, recall, F1 score, accuracy default selection (see multi-omics vignette section 5 details). following example employs penalty term greatest testing prediction accuracy execute SPLSDA algorithm entire dataset. step, steps consistent single-omics quantitative phenotype example, refer section 1.4 1.5 information.","code":"# save cross-validation result cv_result <- aggregateCVSingle(CVDir, \"SmCCA\", NumSubsamp = subSamp, K = 3)  # create directory to save overall result with the best penalty term plotD <- paste0(CVDir, \"Figures/\") saveD <- paste0(CVDir, \"Results/\") dataF <- paste0(CVDir, \"Data.Rdata\") dir.create(plotD) dir.create(saveD) dir.create(dataF)  # specify method (only SmCCA works) Method = \"SmCCA\"  for(Method in \"SmCCA\"){   # read cross validation result in   T12 <- read.csv(paste0(CVDir, \"Results/\", Method, \"CVmeanDeltaCors.csv\"))   # determine the optimal penalty term   pen <- T12[which.max(T12[ ,3]) ,2]   l1 <- pen;   system.time({     # run SPLSDA with optimal penalty term     Ws <- getRobustWeightsSingleBinary(X1 = X1, Trait = as.matrix(Y),                                         Lambda1 = l1,                                         s1, SubsamplingNum = subSamp)         # get adjacency matrix     Abar <- getAbar(Ws, FeatureLabel = AbarLabel[1:p1])     # save result into local directory     save(l1, X1, Y, s1, Ws, Abar,          file = paste0(saveD, Method, K, \"foldSamp\", subSamp, \"_\", pen,                         \".Rdata\"))   })       }"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"","code":"sessionInfo() ## R version 4.3.2 (2023-10-31) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 22.04.3 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] grid      parallel  stats     graphics  grDevices utils     datasets  ## [8] methods   base      ##  ## other attached packages: ##  [1] reshape2_1.4.4   shadowtext_0.1.2 lubridate_1.9.3  forcats_1.0.0    ##  [5] stringr_1.5.1    dplyr_1.1.4      purrr_1.0.2      readr_2.1.5      ##  [9] tidyr_1.3.0      tibble_3.2.1     ggplot2_3.4.4    tidyverse_2.0.0  ## [13] SmCCNet_2.0.2    igraph_1.6.0     Matrix_1.6-1.1   pbapply_1.7-2    ##  ## loaded via a namespace (and not attached): ##  [1] sass_0.4.8        utf8_1.2.4        generics_0.1.3    stringi_1.8.3     ##  [5] lattice_0.21-9    hms_1.1.3         digest_0.6.34     magrittr_2.0.3    ##  [9] timechange_0.2.0  evaluate_0.23     fastmap_1.1.1     plyr_1.8.9        ## [13] jsonlite_1.8.8    fansi_1.0.6       scales_1.3.0      textshaping_0.3.7 ## [17] jquerylib_0.1.4   cli_3.6.2         rlang_1.1.3       munsell_0.5.0     ## [21] withr_2.5.2       cachem_1.0.8      yaml_2.3.8        tools_4.3.2       ## [25] tzdb_0.4.0        memoise_2.0.1     colorspace_2.1-0  vctrs_0.6.5       ## [29] R6_2.5.1          lifecycle_1.0.4   fs_1.6.3          ragg_1.2.7        ## [33] pkgconfig_2.0.3   desc_1.4.3        pkgdown_2.0.7     bslib_0.6.1       ## [37] pillar_1.9.0      gtable_0.3.4      Rcpp_1.0.12       glue_1.7.0        ## [41] systemfonts_1.0.5 xfun_0.41         tidyselect_1.2.0  highr_0.10        ## [45] knitr_1.45        farver_2.1.1      htmltools_0.5.7   labeling_0.4.3    ## [49] rmarkdown_2.25    compiler_4.3.2 warnings()"},{"path":"https://kechrislab.github.io/SmCCNet/articles/SmCCNet_Vignette_SingleOmics.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Reconstructing Phenotype-Specific Single-Omics Networks with SmCCNet","text":"Shi, W. J., Zhuang, Y., Russell, P. H., Hobbs, B. D., Parker, M. M., Castaldi, P. J., … & Kechris, K. (2019). Unsupervised discovery phenotype-specific multi-omics networks. Bioinformatics, 35(21), 4336-4343. Vu, T., Litkowski, E. M., Liu, W., Pratte, K. ., Lange, L., Bowler, R. P., … & Kechris, K. J. (2023). NetSHy: network summarization via hybrid approach leveraging topological properties. Bioinformatics, 39(1), btac818.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Weixuan Liu. Maintainer.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Liu W, Zhuang Y, Shi WJ, Vu T, Konigsberg , Pratte K, Saba L, Kechris K (2024). SmCCNet: Sparse Multiple Canonical Correlation Network Analysis Tool. R package version 2.0.2, https://CRAN.R-project.org/package=SmCCNet.","code":"@Manual{,   title = {SmCCNet: Sparse Multiple Canonical Correlation Network Analysis Tool},   author = {Weixuan Liu and Yonghua Zhuang and W. Jenny Shi and Thao Vu and Iain Konigsberg and Katherine Pratte and Laura Saba and Katerina Kechris},   year = {2024},   note = {R package version 2.0.2},   url = {https://CRAN.R-project.org/package=SmCCNet}, }"},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"smccnet-a-comprehensive-tool-for-multi-omics-network-inference-","dir":"","previous_headings":"","what":"Sparse Multiple Canonical Correlation Network Analysis Tool","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"Note: use SmCCNet published research, please cite: Liu, W., Vu, T., Konigsberg, . R., Pratte, K. ., Zhuang, Y., & Kechris, K. J. (2023). SmCCNet 2.0: Upgraded R package Multi-omics Network Inference. bioRxiv, 2023-11. Shi, W. J., Zhuang, Y., Russell, P. H., Hobbs, B. D., Parker, M. M., Castaldi, P. J., … & Kechris, K. (2019). Unsupervised discovery phenotype-specific multi-omics networks. Bioinformatics, 35(21), 4336-4343.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"SmCCNet framework adeptly integrates single multiple omics data types along quantitative binary phenotype interest. offers streamlined setup process can tailored manually configured automatically, ensuring flexible user-friendly experience. algorithm based sparse multiple canonical analysis (SmCCA) designed T omics data types X1, X2, ..., XT along quantitative phenotype Y. SmCCA identifies canonical weights w1, w2, ..., wT maximize sum pairwise canonical correlations omics data Y, subject certain constraints. SmCCNet, LASSO (Least Absolute Shrinkage Selection Operator) used sparsity constraint function. algorithm can operate weighted unweighted modes, depending whether ai, j bi (scaling factors) equal . ai, j bi equal, corresponds weighted version; otherwise, corresponds unweighted version, ai, j = bi = 1 j. sparsity penalties ct determine number features included subnetwork. SmCCNet follows workflow involves creating network similarity matrix using SmCCA canonical weights repeated subsampled omics data phenotype. identifies multi-omics modules relevant phenotype. subsampling scheme enhances network robustness analyzing subset omics features multiple times aggregating results subsampling step.four steps SmCCNet workflow Step : Determine SmCCA sparsity penalties ct. user can select penalties omics feature selection based study purpose /prior knowledge. Alternatively, one can pick sparsity penalties based K-fold cross validation (CV) procedure minimizes total prediction error. K-fold CV procedure ensures selected penalties generalizable similar independent data sets prevents -fitting. Step II: Randomly subsample omics features without replacement, apply SmCCA chosen penalties, compute feature relationship matrix subset. Repeat process many times define similarity matrix average feature relationship matrices. Step III: Apply hierarchical tree cutting similarity matrix find multi-omics networks. step simultaneously identifies multiple subnetworks. Step Iv: Prune summarize network network pruning algorithm.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"smccnet-key-features","dir":"","previous_headings":"","what":"SmCCNet Key Features","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"Unlock Power SmCCNet Key Features: Quantitative Phenotype Binary Phenotype Quantitative Phenotype Binary Phenotype Automated SmCCNet Single Line Code","code":""},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"smccnet-network-visualization","dir":"","previous_headings":"","what":"SmCCNet Network Visualization","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"final network generated SmCCNet can visualized two ways: Shiny Application simply uplooding final .Rdata SmCCNet Visualization Application. Cytoscape Software Cytoscape R package RCy3.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"package-functions","dir":"","previous_headings":"","what":"Package Functions","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"older version SmCCNet package includes four (external) functions: getRobustPseudoWeights(): Compute aggregated (SmCCA) canonical weights. getAbar(): Calculate similarity matrix based canonical weights. getMultiOmicsModules(): Perform hierarchical tree cutting similarity matrix extract clades multi-omics features. plotMultiOmicsNetwork(): Plot (pruned full) multi-omics subnetworks. updated package, functions except getAbar retired package, additional functions added package perform single-/multi-omics SmCCNet quantitative/binary phenotype, use illustrated vignette: aggregateCVSingle(): Saving cross-validation result cross-validation table working directory provide recommendation penalty term selection. classifierEval(): Evaluate binary classifier’s performance respect user-selected metric (accuracy, auc score, precision, recall, f1). dataPreprocess(): simple pipeline preprocess data running SmCCNet (center, scale, coefficient variation filtering regressing covariates). fastAutoSmCCNet(): Automated SmCCNet automatically identifies project problem (single-omics vs multi-omics), type analysis (CCA quantitative phenotype vs. PLS binary phenotype) based input data provided. method automatically preprocess data, choose scaling factors, subsampling percentage, optimal penalty terms, runs complete SmCCNet pipeline without requirement users provide additional information. function store subnetwork information user-provided directory, well return global network evaluation information. Refer automated SmCCNet vignette information. getCanWeightsMulti(): Run Sparse Multiple Canonical Correlation Analysis (SmCCA) return canonical weight. getCanCorMulti(): Get canonical correlation value SmCCA given canonical weight vectors scaling factors. getRobustWeightsMulti(): SmCCNet algorithm multi-omics data quantitative phenotype. Calculate canonical weights SmCCA. getRobustWeightsMultiBinary(): SmCCNet algorithm multi-omics data binary phenotype. First, SmCCA used identify relationship omics (exlude phenotype). , highly connected omics features selected step 1, SPLSDA used identify relationships omics features phenotype(s). sparse PLSDA algorithm binary outcome first compute PLS assuming outcome continuous, extracts multiple latent factors, uses latent factors fit logistic regression, weights latent factor regression parameters. getRobustWeightsSingle(): Compute aggregated (SmCCA) canonical weights single omics data quantitative phenotype. getRobustWeightsSingleBinary(): Compute aggregated (SmCCA) canonical weights single omics data binary phenotype. getOmicsModules(): Perform hierarchical tree cutting similarity matrix extract clades omics features. networkPruning(): Extract summarization scores (first 3 NetSHy/regular prinicipal components) specified network module given network size. omics features ranked based PageRank algorithm, top m omics features (m specified subnetwork size) included final subnetwork generate summarization score. PC score, correlation respect phenotype interest calculated stored. addition, correlation individual omics features detected phenotype (Pheno argument) also recorded. final subnetwork adjacency matrix stored user-specified working directory interest. scalingFactorInput(): inputing annotation omics data, uses prompts ask user supply scaling factor intended SmCCNet algorithm prioritize correlation structure interest. scaling factor values supplied numeric nonnegative. summarizeNetSHy(): Implement NetSHy network summarization via hybrid approach summarize network considering network topology Laplacian matrix.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"","code":"# Install package if (!require(\"devtools\")) install.packages(\"devtools\") devtools::install_github(\"KechrisLab/SmCCNet\") # Load package library(SmCCNet)"},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"present examples execute Automated SmCCNet using simulated dataset. demonstration, simulate four datasets: two omics data one phenotype data. cover four cases total, involving combinations single multi-omics data either quantitative binary phenotype. final case demonstrates use regress-approach covariate adjustment. users want run pipeline step--step understand algorithm used, please refer SmCCNet single multi-omics vignettes details. Global network information stored object ‘result’, subnetwork information stored directory user provide. information using Cytoscape visualize subnetworks, please refer multi-omics vignette section 3.1.","code":"library(SmCCNet) set.seed(123) data(\"ExampleData\") Y_binary <- ifelse(Y > quantile(Y, 0.5), 1, 0) # single-omics with binary phenotype result <- fastAutoSmCCNet(X = list(X1), Y = as.factor(Y_binary),                            Kfold = 3,                            subSampNum = 100, DataType = c('Gene'),                           saving_dir = getwd(), EvalMethod = 'auc',                            summarization = 'NetSHy',                            CutHeight = 1 - 0.1^10, ncomp_pls = 5) # single-omics with quantitative phenotype result <- fastAutoSmCCNet(X = list(X1), Y = Y, Kfold = 3,                            preprocess = FALSE,                           subSampNum = 50, DataType = c('Gene'),                           saving_dir = getwd(), summarization = 'NetSHy',                           CutHeight = 1 - 0.1^10) # multi-omics with binary phenotype result <- fastAutoSmCCNet(X = list(X1,X2), Y = as.factor(Y_binary),                            Kfold = 3, subSampNum = 50,                            DataType = c('Gene', 'miRNA'),                            CutHeight = 1 - 0.1^10,                           saving_dir = getwd(),                            EvalMethod = 'auc',                            summarization = 'NetSHy',                           BetweenShrinkage = 5,                            ncomp_pls = 3) # multi-omics with quantitative phenotype result <- fastAutoSmCCNet(X = list(X1,X2), Y = Y,                            K = 3, subSampNum = 50,                            DataType = c('Gene', 'miRNA'),                            CutHeight = 1 - 0.1^10,                           saving_dir = getwd(),                             summarization = 'NetSHy',                           BetweenShrinkage = 5)"},{"path":"https://kechrislab.github.io/SmCCNet/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Sparse Multiple Canonical Correlation Network Analysis Tool","text":"encounter bug, please file issue reproducible example GitHub. questions discussion, please use community.rstudio.com. package developed KechrisLab, questions package, please contact Dr. Katerina Kechris Weixuan Liu.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/X1.html","id":null,"dir":"Reference","previous_headings":"","what":"A synthetic mRNA expression dataset. — X1","title":"A synthetic mRNA expression dataset. — X1","text":"matrix containing simulated mRNA expression levels 358 subjects (rows) 500 features (columns).","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/X1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A synthetic mRNA expression dataset. — X1","text":"","code":"X1"},{"path":"https://kechrislab.github.io/SmCCNet/reference/X1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A synthetic mRNA expression dataset. — X1","text":"object class matrix (inherits array) 358 rows 500 columns.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/X2.html","id":null,"dir":"Reference","previous_headings":"","what":"A synthetic miRNA expression dataset. — X2","title":"A synthetic miRNA expression dataset. — X2","text":"matrix containing simulated miRNA expression levels 358 subjects (rows) 100 features (columns).","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/X2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A synthetic miRNA expression dataset. — X2","text":"","code":"X2"},{"path":"https://kechrislab.github.io/SmCCNet/reference/X2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A synthetic miRNA expression dataset. — X2","text":"object class matrix (inherits array) 358 rows 100 columns.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/Y.html","id":null,"dir":"Reference","previous_headings":"","what":"A synthetic phenotype dataset. — Y","title":"A synthetic phenotype dataset. — Y","text":"matrix containing simulated quantitative phenotype measures 358  subjects (rows).","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/Y.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A synthetic phenotype dataset. — Y","text":"","code":"Y"},{"path":"https://kechrislab.github.io/SmCCNet/reference/Y.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A synthetic phenotype dataset. — Y","text":"object class matrix (inherits array) 358 rows 1 columns.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/aggregateCVSingle.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate and Save Cross-validation Result for Single-omics Analysis — aggregateCVSingle","title":"Aggregate and Save Cross-validation Result for Single-omics Analysis — aggregateCVSingle","text":"Saves cross-validation results table user-defined directory outputs penalty term highest testing canonical correlation, lowest prediction error, lowest scaled prediction error.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/aggregateCVSingle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate and Save Cross-validation Result for Single-omics Analysis — aggregateCVSingle","text":"","code":"aggregateCVSingle(CVDir, SCCAmethod = \"SmCCA\", K = 5, NumSubsamp = 500)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/aggregateCVSingle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate and Save Cross-validation Result for Single-omics Analysis — aggregateCVSingle","text":"CVDir directory result stored. SCCAmethod canonical correlation analysis method used model, used name cross-validation table file, default set 'SmCCA'. K number folds cross-validation. NumSubsamp Number subsampling used.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/aggregateCVSingle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate and Save Cross-validation Result for Single-omics Analysis — aggregateCVSingle","text":"vector length 3 indices penalty term (1) maximize testing canonical correlation, (2) minimize prediction error (3) minimize scaled prediction error.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/classifierEval.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluation of Binary Classifier with Different Evaluation Metrics — classifierEval","title":"Evaluation of Binary Classifier with Different Evaluation Metrics — classifierEval","text":"Evaluate binary classifier's performance respect user-selected metric (accuracy, auc score, precision, recall, f1 score) binary phenotype.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/classifierEval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluation of Binary Classifier with Different Evaluation Metrics — classifierEval","text":"","code":"classifierEval(   obs,   pred,   EvalMethod = \"accuracy\",   BinarizeThreshold = 0.5,   print_score = TRUE )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/classifierEval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluation of Binary Classifier with Different Evaluation Metrics — classifierEval","text":"obs Observed phenotype, vector consists 0, 1. pred Predicted probability phenotype, vector consists value 0 1 EvalMethod Binary classifier evaluation method, one following: 'accuracy' (default), 'auc', 'precision', 'recall', 'f1'. BinarizeThreshold Cutoff threshold binarize predicted probability, default set  0.5. print_score Whether print evaluation score, default set TRUE.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/classifierEval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluation of Binary Classifier with Different Evaluation Metrics — classifierEval","text":"evaluation score corresponding selected metric.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/classifierEval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluation of Binary Classifier with Different Evaluation Metrics — classifierEval","text":"","code":"# simulate observed binary phenotype obs <- rbinom(100,1,0.5) # simulate predicted probability pred <- runif(100, 0,1) # calculate the score pred_score <- classifierEval(obs, pred, EvalMethod = 'f1', print_score = FALSE)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/dataPreprocess.html","id":null,"dir":"Reference","previous_headings":"","what":"preprocess a omics dataset before running omics SmCCNet — dataPreprocess","title":"preprocess a omics dataset before running omics SmCCNet — dataPreprocess","text":"Data preprocess pipeline : (1) filter coefficient variation (cv), (2) center scale data (3) adjust clinical covariates.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/dataPreprocess.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"preprocess a omics dataset before running omics SmCCNet — dataPreprocess","text":"","code":"dataPreprocess(   X,   covariates = NULL,   is_cv = FALSE,   cv_quantile = 0,   center = TRUE,   scale = TRUE )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/dataPreprocess.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"preprocess a omics dataset before running omics SmCCNet — dataPreprocess","text":"X dataframe size \\(n\\) \\(p\\), \\(n\\) sample size \\(p\\) feature size. covariates dataframe covariates adjusted . is_cv Whether use coefficient variation filter (small cv filter ). cv_quantile CV filtering quantile. center Whether center dataset X. scale Whether scale dataset X.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/dataPreprocess.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"preprocess a omics dataset before running omics SmCCNet — dataPreprocess","text":"Processed omics data size nxp.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/dataPreprocess.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"preprocess a omics dataset before running omics SmCCNet — dataPreprocess","text":"","code":"X1 <- as.data.frame(matrix(rnorm(600, 0, 1), nrow = 60)) covar <- as.data.frame(matrix(rnorm(120, 0, 1), nrow = 60)) processed_data <- dataPreprocess(X = X1, covariates = covar, is_cv = TRUE,  cv_quantile = 0.5, center = TRUE, scale = TRUE)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/fastAutoSmCCNet.html","id":null,"dir":"Reference","previous_headings":"","what":"Automated SmCCNet to Streamline the SmCCNet Pipeline — fastAutoSmCCNet","title":"Automated SmCCNet to Streamline the SmCCNet Pipeline — fastAutoSmCCNet","text":"Automated SmCCNet automatically identifies project problem (single-omics vs multi-omics),  type analysis (CCA quantitative phenotype vs. PLS binary phenotype)  based input data provided. method automatically preprocesses data,  chooses scaling factors, subsampling percentage, optimal penalty terms,  runs complete SmCCNet pipeline without requirement users provide additional information.  function store subnetwork information user-defined directory, well return global network evaluation information.  Refer automated SmCCNet vignette information.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/fastAutoSmCCNet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automated SmCCNet to Streamline the SmCCNet Pipeline — fastAutoSmCCNet","text":"","code":"fastAutoSmCCNet(   X,   Y,   AdjustedCovar = NULL,   preprocess = FALSE,   Kfold = 5,   EvalMethod = \"accuracy\",   subSampNum = 100,   DataType,   BetweenShrinkage = 2,   ScalingPen = c(0.1, 0.1),   CutHeight = 1 - 0.1^10,   min_size = 10,   max_size = 100,   summarization = \"NetSHy\",   saving_dir = getwd(),   ncomp_pls = 3,   tuneLength = 5,   tuneRangeCCA = c(0.1, 0.5),   tuneRangePLS = c(0.5, 0.9),   seed = 123 )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/fastAutoSmCCNet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automated SmCCNet to Streamline the SmCCNet Pipeline — fastAutoSmCCNet","text":"X list matrices set order subjects (\\(n\\)). Y Phenotype variable either numeric binary, binary variable, binary \\(Y\\), binarized 0,1 running function. AdjustedCovar data frame covariates interest adjusted regressing-approach, argument preprocess need set TRUE adjusting covariates supplied. preprocess Whether data preprocessing step conducted, default set FALSE. regressing covariates needed, provide corresponding covariates AdjustCovar argument. Kfold Number folds cross-validation, default set 5. EvalMethod evaluation methods used selected optimal penalty parameter(s) binary phenotype given. selections among 'accuracy', 'auc', 'precision', 'recall', 'f1', default set 'accuracy'. subSampNum Number subsampling run, higher better terms accuracy, cost computational time, generally recommend 500-1000 increase robustness larger data, default set 100. DataType vector indicating annotation dataset \\(X\\), example c('gene', 'miRNA'). BetweenShrinkage real number > 0 helps shrink importance omics-omics correlation component, larger number , greater shrinkage , default set 2. ScalingPen numeric vector length 2 used penalty terms scaling factor determination method: default set 0.1 datasets,  0 1. CutHeight numeric value specifying cut height hierarchical clustering, 0 1, default set 1 - 0.1^10. min_size Minimally possible subnetwork size network pruning, default set 10. max_size Maximally possible subnetwork size network pruning, default set 100. summarization Summarization method used network pruning summarization, either 'NetSHy' 'PCA'. saving_dir Directory user like store subnetwork results, default set current working directory. ncomp_pls Number components PLS algorithm, used binary phenotype given, default set 3. tuneLength total number candidate penalty term values omics data, default set 5. tuneRangeCCA vector length 2 represents range candidate penalty term values omics data based canonical correlation analysis,  default set c(0.1,0.5). tuneRangePLS vector length 2 represents range candidate penalty term values omics data based partial least squared discriminant analysis,  default set c(0.5,0.9). seed Random seed result reproducibility, default set 123.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/fastAutoSmCCNet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automated SmCCNet to Streamline the SmCCNet Pipeline — fastAutoSmCCNet","text":"function returns global adjacency matrix, omics data details, network clustering outcomes, cross-validation results. Pruned subnetwork modules saved directory specified user.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/fastAutoSmCCNet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automated SmCCNet to Streamline the SmCCNet Pipeline — fastAutoSmCCNet","text":"","code":"# library(SmCCNet) # set.seed(123) # data(\"ExampleData\") # Y_binary <- ifelse(Y > quantile(Y, 0.5), 1, 0) ## single-omics PLS # result <- fastAutoSmCCNet(X = list(X1), Y = as.factor(Y_binary), Kfold = 3,  #                          subSampNum = 100, DataType = c('Gene'), #                          saving_dir = getwd(), EvalMethod = 'auc',  #                          summarization = 'NetSHy',  #                          CutHeight = 1 - 0.1^10, ncomp_pls = 5) ## single-omics CCA # result <- fastAutoSmCCNet(X = list(X1), Y = Y, Kfold = 3, preprocess = FALSE, #                           subSampNum = 50, DataType = c('Gene'), #                           saving_dir = getwd(), summarization = 'NetSHy', #                           CutHeight = 1 - 0.1^10) ## multi-omics PLS # result <- fastAutoSmCCNet(X = list(X1,X2), Y = as.factor(Y_binary),  #                           Kfold = 3, subSampNum = 50,  #                           DataType = c('Gene', 'miRNA'),  #                           CutHeight = 1 - 0.1^10, #                           saving_dir = getwd(), EvalMethod = 'auc',  #                           summarization = 'NetSHy', #                           BetweenShrinkage = 5, ncomp_pls = 3) ## multi-omics CCA # result <- fastAutoSmCCNet(X = list(X1,X2), Y = Y,  #                           K = 3, subSampNum = 50, DataType = c('Gene', 'miRNA'),  #                           CutHeight = 1 - 0.1^10, #                           saving_dir = getwd(),   #                           summarization = 'NetSHy', #                           BetweenShrinkage = 5)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getAbar.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate similarity matrix based on canonical weights. — getAbar","title":"Calculate similarity matrix based on canonical weights. — getAbar","text":"Compute similarity matrix based outer products absolute canonical correlation weights, can used single multi-omics setting.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getAbar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate similarity matrix based on canonical weights. — getAbar","text":"","code":"getAbar(Ws, FeatureLabel = NULL)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getAbar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate similarity matrix based on canonical weights. — getAbar","text":"Ws canonical correlation weight vector matrix. Ws matrix, column corresponds one weight vector. FeatureLabel vector feature labels feature adjacency matrix","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getAbar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate similarity matrix based on canonical weights. — getAbar","text":"\\(p\\times p\\) symmetric non-negative matrix.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getAbar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate similarity matrix based on canonical weights. — getAbar","text":"","code":"w <- matrix(rnorm(6), nrow = 3) Ws <- apply(w, 2, function(x)return(x/sqrt(sum(x^2)))) abar <- getAbar(Ws,  FeatureLabel = c('omics1', 'omics2', 'omics3'))"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCCAout_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions called by getRobustPseudoWeights_single. — getCCAout_single","title":"Internal functions called by getRobustPseudoWeights_single. — getCCAout_single","text":"Internal functions called getRobustPseudoWeights_single.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCCAout_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions called by getRobustPseudoWeights_single. — getCCAout_single","text":"","code":"getCCAout_single(X1, Trait, Lambda1, trace = FALSE)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCCAout_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions called by getRobustPseudoWeights_single. — getCCAout_single","text":"X1 data. Trait phenotype. Lambda1 penalty term trace Whether display CCA algorithm trace.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanCorMulti.html","id":null,"dir":"Reference","previous_headings":"","what":"Canonical Correlation Value for SmCCA — getCanCorMulti","title":"Canonical Correlation Value for SmCCA — getCanCorMulti","text":"Calculate canonical correlation value SmCCA given canonical weight vectors scaling factor","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanCorMulti.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Canonical Correlation Value for SmCCA — getCanCorMulti","text":"","code":"getCanCorMulti(X, CCcoef, CCWeight, Y)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanCorMulti.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Canonical Correlation Value for SmCCA — getCanCorMulti","text":"X list data number subjects. CCcoef vector scaling factors indicating weights pairwise canonical correlation. CCWeight list canonical weight vectors corresponds data \\(X\\). Y phenotype matrix, one column.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanCorMulti.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Canonical Correlation Value for SmCCA — getCanCorMulti","text":"numeric value total canonical correlation","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanCorMulti.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Canonical Correlation Value for SmCCA — getCanCorMulti","text":"","code":"library(SmCCNet) data(\"ExampleData\") getCanCorMulti(list(X1,X2), CCcoef = c(1,1,1),  CCWeight = list(rnorm(500,0,1), rnorm(100,0,1)), Y = Y) #> [1] 0.1212695"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanWeightsMulti.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Canonical Weight SmCCA Algorithm (No Subsampling) — getCanWeightsMulti","title":"Get Canonical Weight SmCCA Algorithm (No Subsampling) — getCanWeightsMulti","text":"Run Sparse multiple Canonical Correlation Analysis (SmCCA) return canonical weight vectors.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanWeightsMulti.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Canonical Weight SmCCA Algorithm (No Subsampling) — getCanWeightsMulti","text":"","code":"getCanWeightsMulti(   X,   Trait = NULL,   Lambda,   CCcoef = NULL,   NoTrait = TRUE,   trace = FALSE,   TraitWeight = FALSE )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanWeightsMulti.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Canonical Weight SmCCA Algorithm (No Subsampling) — getCanWeightsMulti","text":"X list omics data n subjects. Trait \\(n\\) 1 trait (phenotype) data samples. Lambda Lasso penalty vector length equals number omics data (\\(X\\)). Lambda needs 0 1. CCcoef Optional scaling factors SmCCA pairwise canonical correlations. CCcoef = NULL (default), objective function total sum pairwise canonical correlations. follows column order combn(T+1, 2), T total number omics data. NoTrait Whether trait (phenotype) information provided, default set TRUE. trace Whether display CCA algorithm trace, default set FALSE. TraitWeight Whether return canonical weight trait (phenotype), default set FALSE.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanWeightsMulti.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Canonical Weight SmCCA Algorithm (No Subsampling) — getCanWeightsMulti","text":"canonical weight vector size \\(p\\) 1.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getCanWeightsMulti.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Canonical Weight SmCCA Algorithm (No Subsampling) — getCanWeightsMulti","text":"","code":"# This function is typically used as an internal function. # It is also used when performing cross-validation, # refer to multi-omics vignette for more detail. # X <- list(X1,X2) # result <- getCanWeightsMulti(X, Trait = as.matrix(Y), Lambda = c(0.5,0.5), NoTrait = FALSE) # result <- getCanWeightsMulti(X, Trait = NULL, Lambda = c(0.5,0.5), NoTrait = TRUE) # cccoef <- c(1,10,10) # result <- getCanWeightsMulti(X, Trait = as.matrix(Y), CCcoef = cccoef,  #                              Lambda = c(0.5,0.5), NoTrait = FALSE)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getOmicsModules.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Omics Modules based on Similarity Matrix. — getOmicsModules","title":"Extract Omics Modules based on Similarity Matrix. — getOmicsModules","text":"Apply hierarchical tree cutting similarity matrix extract multi/single-omics network modules.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getOmicsModules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Omics Modules based on Similarity Matrix. — getOmicsModules","text":"","code":"getOmicsModules(Abar, CutHeight = 1 - 0.1^10, PlotTree = TRUE)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getOmicsModules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Omics Modules based on Similarity Matrix. — getOmicsModules","text":"Abar similary matrix features (omics data types). CutHeight Height threshold hierarchical tree cutting. Default \\(1-0.1^{10}\\). PlotTree Logical. Whether create hierarchical tree plot, default set TRUE.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getOmicsModules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Omics Modules based on Similarity Matrix. — getOmicsModules","text":"list multi/single-omics modules.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getOmicsModules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Omics Modules based on Similarity Matrix. — getOmicsModules","text":"","code":"set.seed(123) w <- rnorm(5) w <- w/sqrt(sum(w^2)) feature_name <- paste0('feature_', 1:5) abar <- getAbar(w, FeatureLabel = feature_name) modules <- getOmicsModules(abar, CutHeight = 0.5)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMulti.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMulti","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMulti","text":"SmCCNet algorithm multi-omics data quantitative phenotype. Calculate canonical weights SmCCA.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMulti.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMulti","text":"","code":"getRobustWeightsMulti(   X,   Trait,   Lambda,   s = NULL,   NoTrait = FALSE,   SubsamplingNum = 1000,   CCcoef = NULL,   trace = FALSE,   TraitWeight = FALSE )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMulti.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMulti","text":"X list omics data n subjects. Trait \\(n\\times 1\\) trait (phenotype) data matrix n subjects. Lambda Lasso penalty vector length equals number omics data (\\(X\\)). Lambda needs 0 1. s vector length equals number omics data (\\(X\\)), specifying  percentage omics feature subsampled subsampling iteration. NoTrait Logical, default FALSE. Whether trait information provided. SubsamplingNum Number feature subsamples. Default 1000. Larger number leads accurate results, higher computational cost. CCcoef Optional scaling factors SmCCA pairwise canonical correlations. CCcoef = NULL (default), objective function total sum pairwise canonical correlations.  coefficient vector follows column order combn(T+1, 2) assuming T omics data phenotype data. trace Whether display CCA algorithm trace, default set FALSE. TraitWeight Whether return canonical weight trait (phenotype), default set FALSE.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMulti.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMulti","text":"canonical correlation weight matrix \\(p = \\sum_{} p_i\\) rows, \\(p_i\\) number features \\(\\)th omics. column canonical correlation weights based subsampled features. number columns SubsamplingNum.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMulti.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMulti","text":"","code":"## For illustration, we only subsample 5 times. set.seed(123) X1 <- matrix(rnorm(600,0,1), nrow = 60) X2 <- matrix(rnorm(600,0,1), nrow = 60) Y <- matrix(rnorm(60,0,1), nrow = 60) # Unweighted SmCCA result <- getRobustWeightsMulti(X = list(X1, X2), Trait = Y, NoTrait = FALSE, Lambda = c(0.5, 0.5),s = c(0.7, 0.7), SubsamplingNum = 20)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMultiBinary.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMultiBinary","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMultiBinary","text":"SmCCNet algorithm multi-omics data binary phenotype. stepwise approach  (1) use SmCCA identify relationship omics (exlude phenotype), (2) within highly connected omics features selected step 1, identify relationship selected omics features phenotype interest  sparse PLS. First, computes PLSDA assuming outcome continuous extract multiple latent factors, uses latent factors fit logistic regression, weight latent factor regression parameters. Refer multi-omics vignette detail.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMultiBinary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMultiBinary","text":"","code":"getRobustWeightsMultiBinary(   X,   Y,   Between_Discriminate_Ratio = c(1, 1),   SubsamplingPercent = NULL,   CCcoef = NULL,   LambdaBetween,   LambdaPheno = NULL,   SubsamplingNum = 1000,   ncomp_pls = 3,   EvalClassifier = FALSE,   testData = NULL )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMultiBinary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMultiBinary","text":"X list omics data n subjects. Y vector binary variable, user needs set level  variable 0 1. Between_Discriminate_Ratio vector length 2 specifying relative importance -omics relationship omics-phenotype relationship. instance ratio 1:1 (c(1,1) argument) means -omics relationship omics-phenotype relationship contribute equally canonical weights extraction. SubsamplingPercent vector length equal number omics data (X), specifying  percentage omics feature subsampled subsampling iteration. CCcoef vector scaling factors -omics relationship (exclude omics-phenotype).  coefficient vector follows column order combn(T, 2) T omics data. LambdaBetween vector sparsity penalty value omics data run -omics SmCCA,  penalty term within range 0 1. LambdaPheno penalty term running sparse PLS phenotype, penalty term within range 0 1. SubsamplingNum Number feature subsamples. Default 1000. Larger number leads accurate results, higher computational cost, default set 1000. ncomp_pls Number latent components PLS, default set 3. EvalClassifier TRUE, algorithm phase evaluating classification performance, latent factors SPLSDA returned; FALSE, algorithm phase constructing multi-omics network, canonical weight returned.  Default set FALSE. testData list testing omics data matrix, exact order data list X, used EvalClassifier set TRUE performing cross-validation, refer multi-omics vignette detail.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMultiBinary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMultiBinary","text":"EvalClassifier set FALSE, canonical correlation weight matrix returned combined omics data. column canonical correlation weights based subsampled X features. number columns SubsamplingNum. EvalClassifier set TRUE, latent factors training testing data returned classifier evaluation.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsMultiBinary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Sparse multiple Canonical Correlation Analysis and Obtain Canonical Weights (with Subsampling) — getRobustWeightsMultiBinary","text":"","code":"## For illustration, we only subsample 5 times. set.seed(123) X1 <- matrix(rnorm(600,0,1), nrow = 60) X2 <- matrix(rnorm(600,0,1), nrow = 60) Y_binary <- rbinom(60,1,0.5)  Ws <- getRobustWeightsMultiBinary(list(X1,X2), Y_binary,        SubsamplingPercent = c(0.8,0.8), CCcoef = NULL,       LambdaBetween = c(0.5,0.5), LambdaPheno = 0.1, SubsamplingNum = 10)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingle.html","id":null,"dir":"Reference","previous_headings":"","what":"Single-omics SmCCA with Quantitative Phenotype — getRobustWeightsSingle","title":"Single-omics SmCCA with Quantitative Phenotype — getRobustWeightsSingle","text":"Compute aggregated (SmCCA) canonical weights single omics data quantitative phenotype (subampling enabled).","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single-omics SmCCA with Quantitative Phenotype — getRobustWeightsSingle","text":"","code":"getRobustWeightsSingle(   X1,   Trait,   Lambda1,   s1 = 0.7,   SubsamplingNum = 1000,   trace = FALSE )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single-omics SmCCA with Quantitative Phenotype — getRobustWeightsSingle","text":"X1 \\(n\\times p_1\\) data matrix (e.g. mRNA) \\(p_1\\) features \\(n\\) subjects. Trait \\(n\\times 1\\) trait (phenotype) data matrix \\(n\\) subjects. Lambda1 LASSO penalty parameter X1. Lambda1 needs 0 1. s1 Proportion features X1 included, default s1 = 0.7. s1 needs 0 1, default set 0.7. SubsamplingNum Number feature subsamples. Default 1000. Larger number leads accurate results, higher computational cost. trace Whether display CCA algorithm trace, default set FALSE.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single-omics SmCCA with Quantitative Phenotype — getRobustWeightsSingle","text":"canonical correlation weight matrix \\(p_1\\) rows. column canonical correlation weights based subsampled X1 features. number columns SubsamplingNum.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Single-omics SmCCA with Quantitative Phenotype — getRobustWeightsSingle","text":"","code":"## For illustration, we only subsample 5 times. set.seed(123)  # Single Omics SmCCA W1 <- getRobustWeightsSingle(X1, Trait = Y, Lambda1 = 0.05,   s1 = 0.7,    SubsamplingNum = 5, trace = FALSE)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingleBinary.html","id":null,"dir":"Reference","previous_headings":"","what":"Single-omics SmCCA with Binary Phenotype — getRobustWeightsSingleBinary","title":"Single-omics SmCCA with Binary Phenotype — getRobustWeightsSingleBinary","text":"Compute aggregated (SmCCA) canonical weights single omics data quantitative phenotype (subampling enabled).","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingleBinary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single-omics SmCCA with Binary Phenotype — getRobustWeightsSingleBinary","text":"","code":"getRobustWeightsSingleBinary(   X1,   Trait,   Lambda1,   s1 = 0.7,   SubsamplingNum = 1000,   K = 3 )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingleBinary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single-omics SmCCA with Binary Phenotype — getRobustWeightsSingleBinary","text":"X1 \\(n\\times p_1\\) data matrix (e.g. mRNA) \\(p_1\\) features \\(n\\) subjects. Trait \\(n\\times 1\\) trait (phenotype) data matrix \\(n\\) subjects. Lambda1 LASSO penalty parameter X1. Lambda1 needs 0 1. s1 Proportion mRNA features included, default s1 = 0.7. s1 needs 0 1, default set 0.7. SubsamplingNum Number feature subsamples. Default 1000. Larger number leads accurate results, higher computational cost. K Number hidden components PLSDA, default set 3.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingleBinary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single-omics SmCCA with Binary Phenotype — getRobustWeightsSingleBinary","text":"partial least squared weight matrix \\(p_1\\) rows. column canonical correlation weights based subsampled X1 features. number columns SubsamplingNum.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/getRobustWeightsSingleBinary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Single-omics SmCCA with Binary Phenotype — getRobustWeightsSingleBinary","text":"","code":"X <- matrix(rnorm(600,0,1), nrow = 60) Y <- rbinom(60,1,0.5) Ws <- getRobustWeightsSingleBinary(X1 = X, Trait = as.matrix(Y), Lambda1 = 0.8,  0.7, SubsamplingNum = 10)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/networkPruning.html","id":null,"dir":"Reference","previous_headings":"","what":"Prunes Subnetwork and Return Final Pruned Subnetwork Module — networkPruning","title":"Prunes Subnetwork and Return Final Pruned Subnetwork Module — networkPruning","text":"Prunes subnetworks network pruning algorithm (see multi-omics vignette detail), save final pruned subnetwork user-defined directory. final subnetwork .Rdata file name 'size_m_net_ind.Rdata', \\(m\\) final pruned network size, ind index subnetwork module hierarchical clustering.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/networkPruning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prunes Subnetwork and Return Final Pruned Subnetwork Module — networkPruning","text":"","code":"networkPruning(   Abar,   CorrMatrix,   data,   Pheno,   type,   ModuleIdx,   min_mod_size = 10,   max_mod_size,   damping = 0.9,   method = \"NetSHy\",   saving_dir )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/networkPruning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prunes Subnetwork and Return Final Pruned Subnetwork Module — networkPruning","text":"Abar Adjacency matrix subnetwork size \\(m^{*}\\) \\(m^{*}\\) hierarchical clustering. CorrMatrix correlation matrix features Abar, \\(m^{*}\\) \\(m^{*}\\) well. data omics data subnetwork. Pheno trait (phenotype) data used network pruning. type vector length equal total number features adjacency matrix indicating type data feature. instance, subnetwork 2 genes protein, type argument set c('gene', 'gene', 'protein'), see multi-omics vignette information. ModuleIdx index network module summarization score intended stored, used naming subnetwork file user-defined directory. min_mod_size minimally possible subnetwork size pruned network module, integer 1 largest possible size subnetwork, default set 10. max_mod_size maximally possible subnetwork size pruned network module, integer 1 largest possible size subnetwork, needs greater value specified min_mod_size. damping damping parameter PageRank algorithm, default set 0.9, see igraph package detail. method Selection NetSHy' 'PCA', specifying network summarization method used network pruning, default set NetSHy. saving_dir User-defined directory store pruned subnetwork.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/networkPruning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prunes Subnetwork and Return Final Pruned Subnetwork Module — networkPruning","text":"file stored user-defined directory, contains following: (1) correlation_sub: correlation matrix subnetwork. (2) M: adjacency matrix subnetwork. (3) omics_corelation_data: individual molecular feature correlation phenotype. (4) pc_correlation: first 3 PCs correlation phenotype. (5) pc_loading: principal component loadings. (6) pca_x1_score: principal component score phenotype data. (7) mod_size: number molecular features subnetwork. (8) sub_type: type feature molecular features.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/networkPruning.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prunes Subnetwork and Return Final Pruned Subnetwork Module — networkPruning","text":"","code":"library(SmCCNet) set.seed(123) w <- rnorm(20) w <- w/sqrt(sum(w^2)) labels <- paste0('feature_', 1:20) abar <- getAbar(w, FeatureLabel = labels) modules <- getOmicsModules(abar, CutHeight = 0.1)  x <- X1[ ,seq_len(20)] corr <- stats::cor(x) # display only example # networkPruning(abar, corr, data = x, Pheno = Y, # ModuleIdx = 1,  min_mod_size = 3, max_mod_size = 10, method = 'NetSHy', saving_dir =  # )"},{"path":"https://kechrislab.github.io/SmCCNet/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://kechrislab.github.io/SmCCNet/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/scalingFactorInput.html","id":null,"dir":"Reference","previous_headings":"","what":"Scaling Factor Input Prompt — scalingFactorInput","title":"Scaling Factor Input Prompt — scalingFactorInput","text":"Input vector annotation type dataset data list X (e.g., c('gene', 'protein')), return prompt ask user supply scaling  factor SmCCNet algorithm prioritize correlation structures  interest. scaling factor values supplied numeric nonnegative.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/scalingFactorInput.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scaling Factor Input Prompt — scalingFactorInput","text":"","code":"scalingFactorInput(DataType = NULL)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/scalingFactorInput.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scaling Factor Input Prompt — scalingFactorInput","text":"DataType character vector contains annotation type omics dataset X.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/scalingFactorInput.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scaling Factor Input Prompt — scalingFactorInput","text":"numeric vector scaling factors.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/scalingFactorInput.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scaling Factor Input Prompt — scalingFactorInput","text":"","code":"# not run # scalingFactorInput(c('gene','mirna', 'phenotype'))"},{"path":"https://kechrislab.github.io/SmCCNet/reference/summarizeNetSHy.html","id":null,"dir":"Reference","previous_headings":"","what":"NetSHy Summarization Score — summarizeNetSHy","title":"NetSHy Summarization Score — summarizeNetSHy","text":"Implement NetSHy network summarization via hybrid approach (Vu et al.,)  summarize network considering network topology Laplacian matrix.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/summarizeNetSHy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"NetSHy Summarization Score — summarizeNetSHy","text":"","code":"summarizeNetSHy(X, A, npc = 1)"},{"path":"https://kechrislab.github.io/SmCCNet/reference/summarizeNetSHy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"NetSHy Summarization Score — summarizeNetSHy","text":"X \\(n\\times m\\) data matrix  \\(m\\) features \\(n\\) subjects. Corresponding adjacency matrix size \\(p\\) \\(p\\). npc Number principal components used summarize network, default set 1.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/summarizeNetSHy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"NetSHy Summarization Score — summarizeNetSHy","text":"list consists (1) subject-level network summarization score, (2) principal component importance information: standard deviation, percent variance explained, cumulative proportion variance explained, (3) principal component feature-level loadings.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/summarizeNetSHy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"NetSHy Summarization Score — summarizeNetSHy","text":"Vu, Thao, Elizabeth M. Litkowski, Weixuan Liu, Katherine . Pratte, Leslie Lange, Russell P. Bowler, Farnoush Banaei-Kashani, Katerina J. Kechris. \"NetSHy: network summarization via hybrid approach leveraging topological properties.\" Bioinformatics 39, . 1 (2023): btac818.","code":""},{"path":"https://kechrislab.github.io/SmCCNet/reference/summarizeNetSHy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"NetSHy Summarization Score — summarizeNetSHy","text":"","code":"# simulate omics data OmicsData <- matrix(rnorm(200,0,1), nrow = 10, ncol = 20) # simulate omics adjacency matrix set.seed(123) w <- rnorm(20) w <- w/sqrt(sum(w^2)) featurelabel <- paste0('omics',1:20) abar <- getAbar(w, FeatureLabel = featurelabel) # extract NetSHy summarization score netshy_score <- summarizeNetSHy(OmicsData, abar)"}]
