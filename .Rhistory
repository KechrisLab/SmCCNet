# If not show nodes.
if(!ShowNodes){vshape <- "none"}
# If no label, assign a place holder.
if(!ShowTypeLabel){node_names <- rep(" ", length(newM.node))}
# Define edge colors.
ecol <- rep("gray80", igraph::ecount(net))
ew <- abs(igraph::edge.attributes(net)$weight) * 5
ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"
ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "red"
# Define network layout.
if(NetLayout == "circle"){
l <- igraph::layout_in_circle(net)
}else if(NetLayout == "sphere"){
l <- igraph::layout_on_sphere(net)
}else if(NetLayout == "fr"){
l <- igraph::layout_with_fr(net)
}else if(NetLayout == "lgl"){
l <- igraph::layout_with_lgl(net)
}else{
stop("Unrecognized NetLayout input. Acceptable options are 'circle',
'sphere', 'fr', and 'lgl'.")
}
# Plotting the network
print(vcol)
print(vshape)
graphics::plot(net, vertex.color = vcol, vertex.shape = vshape,
vertex.label.cex = VertexLabelCex, layout = l,
vertex.size = VertexSize, vertex.label = node_names,
edge.width = ew, vertex.label.color = lcol, edge.color = ecol,
vertex.label.font = 2, main = PlotTitle)
}
}
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "fr")
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl")
type_colors <- c("darkviolet", "darkorange", "midnightblue", "forestgreen", "deeppink")  # Darker color alternatives
plotMultiOmicsNetwork <- function(Abar, CorrMatrix,
ModuleIdx = 1, sub_type, CorrCutOff = 0.2,
AddCorrSign = TRUE,
ShowTypeLabel = TRUE,
PlotTitle = "", NetLayout = "lgl",
ShowNodes = TRUE,
VertexLabelCex = 1, VertexSize = 1){
p <- ncol(Abar)
# Trim the module by CorrCutOff.
M <- as.matrix(Abar)
CorrSubMatrix <- as.matrix(CorrMatrix)
M[which(abs(CorrSubMatrix) < CorrCutOff)] <- 0
if(AddCorrSign){M <- M * sign(CorrSubMatrix)}
M.node <- 1:nrow(Abar)
newM.node <- M.node[which(apply(abs(M), 1, max) > 0)]
# Get the actual names of the nodes from the row names of Abar
node_names <- rownames(Abar)[newM.node]
if(length(newM.node) == 0){
print("No edge passes threshold.")
}else{
M <- M[newM.node, newM.node]
allidx <- matrix(seq_len(p), ncol = 1)
rownames(allidx) <- rownames(Abar)
NodeInfo <- data.frame(id = newM.node, idx = allidx[newM.node, ])
net <- igraph::graph_from_adjacency_matrix(M, weighted = TRUE,
diag = FALSE, mode = "undirected")
# Vertex Color and Shape Definition
k <- length(newM.node)
unique_types <- unique(sub_type)
type_colors <- c("darkviolet", "darkorange", "midnightblue", "forestgreen", "deeppink")  # Darker color alternatives
#type_colors <- c("purple", "dark orange", "blue", "green", "pink")  # Extend color list as needed
type_shapes <- c("square", "circle", "triangle", "diamond", "rectangle")  # Extend shape list as needed
vcol <- type_colors[match(sub_type[newM.node], unique_types)]
vshape <- type_shapes[match(sub_type[newM.node], unique_types)]
lcol <- vcol
# If not show nodes.
if(!ShowNodes){vshape <- "none"}
# If no label, assign a place holder.
if(!ShowTypeLabel){node_names <- rep(" ", length(newM.node))}
# Define edge colors.
ecol <- rep("gray80", igraph::ecount(net))
ew <- abs(igraph::edge.attributes(net)$weight) * 5
ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"
ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "red"
# Define network layout.
if(NetLayout == "circle"){
l <- igraph::layout_in_circle(net)
}else if(NetLayout == "sphere"){
l <- igraph::layout_on_sphere(net)
}else if(NetLayout == "fr"){
l <- igraph::layout_with_fr(net)
}else if(NetLayout == "lgl"){
l <- igraph::layout_with_lgl(net)
}else{
stop("Unrecognized NetLayout input. Acceptable options are 'circle',
'sphere', 'fr', and 'lgl'.")
}
# Plotting the network
graphics::plot(net, vertex.color = vcol, vertex.shape = vshape,
vertex.label.cex = VertexLabelCex, layout = l,
vertex.size = VertexSize, vertex.label = node_names,
edge.width = ew, vertex.label.color = lcol, edge.color = ecol,
vertex.label.font = 2, main = PlotTitle)
}
}
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl")
plotMultiOmicsNetwork <- function(Abar, CorrMatrix,
ModuleIdx = 1, sub_type, CorrCutOff = 0.2,
AddCorrSign = TRUE,
ShowTypeLabel = TRUE,
PlotTitle = "", NetLayout = "lgl",
ShowNodes = TRUE,
VertexLabelCex = 1, VertexSize = 1){
p <- ncol(Abar)
# Trim the module by CorrCutOff.
M <- as.matrix(Abar)
CorrSubMatrix <- as.matrix(CorrMatrix)
M[which(abs(CorrSubMatrix) < CorrCutOff)] <- 0
if(AddCorrSign){M <- M * sign(CorrSubMatrix)}
M.node <- 1:nrow(Abar)
newM.node <- M.node[which(apply(abs(M), 1, max) > 0)]
# Get the actual names of the nodes from the row names of Abar
node_names <- rownames(Abar)[newM.node]
if(length(newM.node) == 0){
print("No edge passes threshold.")
}else{
M <- M[newM.node, newM.node]
allidx <- matrix(seq_len(p), ncol = 1)
rownames(allidx) <- rownames(Abar)
NodeInfo <- data.frame(id = newM.node, idx = allidx[newM.node, ])
net <- igraph::graph_from_adjacency_matrix(M, weighted = TRUE,
diag = FALSE, mode = "undirected")
# Vertex Color and Shape Definition
k <- length(newM.node)
unique_types <- unique(sub_type)
type_colors <- c("darkviolet", "darkred", "midnightblue", "forestgreen", "deeppink")  # Darker color alternatives
#type_colors <- c("purple", "dark orange", "blue", "green", "pink")  # Extend color list as needed
type_shapes <- c("square", "circle", "triangle", "diamond", "rectangle")  # Extend shape list as needed
vcol <- type_colors[match(sub_type[newM.node], unique_types)]
vshape <- type_shapes[match(sub_type[newM.node], unique_types)]
lcol <- vcol
# If not show nodes.
if(!ShowNodes){vshape <- "none"}
# If no label, assign a place holder.
if(!ShowTypeLabel){node_names <- rep(" ", length(newM.node))}
# Define edge colors.
ecol <- rep("gray80", igraph::ecount(net))
ew <- abs(igraph::edge.attributes(net)$weight) * 5
ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"
ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "red"
# Define network layout.
if(NetLayout == "circle"){
l <- igraph::layout_in_circle(net)
}else if(NetLayout == "sphere"){
l <- igraph::layout_on_sphere(net)
}else if(NetLayout == "fr"){
l <- igraph::layout_with_fr(net)
}else if(NetLayout == "lgl"){
l <- igraph::layout_with_lgl(net)
}else{
stop("Unrecognized NetLayout input. Acceptable options are 'circle',
'sphere', 'fr', and 'lgl'.")
}
# Plotting the network
graphics::plot(net, vertex.color = vcol, vertex.shape = vshape,
vertex.label.cex = VertexLabelCex, layout = l,
vertex.size = VertexSize, vertex.label = node_names,
edge.width = ew, vertex.label.color = lcol, edge.color = ecol,
vertex.label.font = 2, main = PlotTitle)
}
}
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl")
plotMultiOmicsNetwork <- function(Abar, CorrMatrix,
ModuleIdx = 1, sub_type, CorrCutOff = 0.2,
AddCorrSign = TRUE,
ShowTypeLabel = TRUE,
PlotTitle = "", NetLayout = "lgl",
ShowNodes = TRUE,
VertexLabelCex = 1, VertexSize = 1){
p <- ncol(Abar)
# Trim the module by CorrCutOff.
M <- as.matrix(Abar)
CorrSubMatrix <- as.matrix(CorrMatrix)
M[which(abs(CorrSubMatrix) < CorrCutOff)] <- 0
if(AddCorrSign){M <- M * sign(CorrSubMatrix)}
M.node <- 1:nrow(Abar)
newM.node <- M.node[which(apply(abs(M), 1, max) > 0)]
# Get the actual names of the nodes from the row names of Abar
node_names <- rownames(Abar)[newM.node]
if(length(newM.node) == 0){
print("No edge passes threshold.")
}else{
M <- M[newM.node, newM.node]
allidx <- matrix(seq_len(p), ncol = 1)
rownames(allidx) <- rownames(Abar)
NodeInfo <- data.frame(id = newM.node, idx = allidx[newM.node, ])
net <- igraph::graph_from_adjacency_matrix(M, weighted = TRUE,
diag = FALSE, mode = "undirected")
# Vertex Color and Shape Definition
k <- length(newM.node)
unique_types <- unique(sub_type)
type_colors <- c("darkviolet", "darkred", "midnightblue", "forestgreen", "deeppink")  # Darker color alternatives
#type_colors <- c("purple", "dark orange", "blue", "green", "pink")  # Extend color list as needed
type_shapes <- c("square", "circle", "triangle", "diamond", "rectangle")  # Extend shape list as needed
vcol <- type_colors[match(sub_type[newM.node], unique_types)]
vshape <- type_shapes[match(sub_type[newM.node], unique_types)]
lcol <- vcol
# If not show nodes.
if(!ShowNodes){vshape <- "none"}
# If no label, assign a place holder.
if(!ShowTypeLabel){node_names <- rep(" ", length(newM.node))}
# Define edge colors.
ecol <- rep("gray80", igraph::ecount(net))
ew <- abs(igraph::edge.attributes(net)$weight) * 5
#ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"
#ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "red"
ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "lightblue"  # Lighter blue for negative edges
ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "lightcoral"  # Lighter red for positive edges
# Define network layout.
if(NetLayout == "circle"){
l <- igraph::layout_in_circle(net)
}else if(NetLayout == "sphere"){
l <- igraph::layout_on_sphere(net)
}else if(NetLayout == "fr"){
l <- igraph::layout_with_fr(net)
}else if(NetLayout == "lgl"){
l <- igraph::layout_with_lgl(net)
}else{
stop("Unrecognized NetLayout input. Acceptable options are 'circle',
'sphere', 'fr', and 'lgl'.")
}
# Plotting the network
graphics::plot(net, vertex.color = vcol, vertex.shape = vshape,
vertex.label.cex = VertexLabelCex, layout = l,
vertex.size = VertexSize, vertex.label = node_names,
edge.width = ew, vertex.label.color = lcol, edge.color = ecol,
vertex.label.font = 2, main = PlotTitle)
}
}
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl")
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 1, VertexSize = 0.2)
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 2, VertexSize = 0.2)
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 0.5, VertexSize = 0.2)
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 0.5, VertexSize = 1)
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 0.8, VertexSize = 1)
plotMultiOmicsNetwork <- function(Abar, CorrMatrix,
ModuleIdx = 1, sub_type, CorrCutOff = 0.2,
AddCorrSign = TRUE,
ShowTypeLabel = TRUE,
PlotTitle = "", NetLayout = "lgl",
ShowNodes = TRUE,
VertexLabelCex = 1, VertexSize = 1){
p <- ncol(Abar)
# Trim the module by CorrCutOff.
M <- as.matrix(Abar)
CorrSubMatrix <- as.matrix(CorrMatrix)
M[which(abs(CorrSubMatrix) < CorrCutOff)] <- 0
if(AddCorrSign){M <- M * sign(CorrSubMatrix)}
M.node <- 1:nrow(Abar)
newM.node <- M.node[which(apply(abs(M), 1, max) > 0)]
# Get the actual names of the nodes from the row names of Abar
node_names <- rownames(Abar)[newM.node]
if(length(newM.node) == 0){
print("No edge passes threshold.")
}else{
M <- M[newM.node, newM.node]
allidx <- matrix(seq_len(p), ncol = 1)
rownames(allidx) <- rownames(Abar)
NodeInfo <- data.frame(id = newM.node, idx = allidx[newM.node, ])
net <- igraph::graph_from_adjacency_matrix(M, weighted = TRUE,
diag = FALSE, mode = "undirected")
# Vertex Color and Shape Definition
k <- length(newM.node)
unique_types <- unique(sub_type)
type_colors <- c("darkviolet", "darkred", "midnightblue", "forestgreen", "deeppink")  # Darker color alternatives
#type_colors <- c("purple", "dark orange", "blue", "green", "pink")  # Extend color list as needed
type_shapes <- c("square", "circle", "triangle", "diamond", "rectangle")  # Extend shape list as needed
vcol <- type_colors[match(sub_type[newM.node], unique_types)]
vshape <- type_shapes[match(sub_type[newM.node], unique_types)]
lcol <- vcol
# If not show nodes.
if(!ShowNodes){vshape <- "none"}
# If no label, assign a place holder.
if(!ShowTypeLabel){node_names <- rep(" ", length(newM.node))}
# Define edge colors.
ecol <- rep("gray80", igraph::ecount(net))
ew <- abs(igraph::edge.attributes(net)$weight) * 5
#ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"
#ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "red"
ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"  # Lighter blue for negative edges
ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "coral"  # Lighter red for positive edges
# Define network layout.
if(NetLayout == "circle"){
l <- igraph::layout_in_circle(net)
}else if(NetLayout == "sphere"){
l <- igraph::layout_on_sphere(net)
}else if(NetLayout == "fr"){
l <- igraph::layout_with_fr(net)
}else if(NetLayout == "lgl"){
l <- igraph::layout_with_lgl(net)
}else{
stop("Unrecognized NetLayout input. Acceptable options are 'circle',
'sphere', 'fr', and 'lgl'.")
}
# Plotting the network
graphics::plot(net, vertex.color = vcol, vertex.shape = vshape,
vertex.label.cex = VertexLabelCex, layout = l,
vertex.size = VertexSize, vertex.label = node_names,
edge.width = ew, vertex.label.color = lcol, edge.color = ecol,
vertex.label.font = 2, main = PlotTitle)
}
}
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 0.8, VertexSize = 1)
plotMultiOmicsNetwork <- function(Abar, CorrMatrix,
ModuleIdx = 1, sub_type, CorrCutOff = 0.2,
AddCorrSign = TRUE,
ShowTypeLabel = TRUE,
PlotTitle = "", NetLayout = "lgl",
ShowNodes = TRUE,
VertexLabelCex = 1, VertexSize = 1){
p <- ncol(Abar)
# Trim the module by CorrCutOff.
M <- as.matrix(Abar)
CorrSubMatrix <- as.matrix(CorrMatrix)
M[which(abs(CorrSubMatrix) < CorrCutOff)] <- 0
if(AddCorrSign){M <- M * sign(CorrSubMatrix)}
M.node <- 1:nrow(Abar)
newM.node <- M.node[which(apply(abs(M), 1, max) > 0)]
# Get the actual names of the nodes from the row names of Abar
node_names <- rownames(Abar)[newM.node]
if(length(newM.node) == 0){
print("No edge passes threshold.")
}else{
M <- M[newM.node, newM.node]
allidx <- matrix(seq_len(p), ncol = 1)
rownames(allidx) <- rownames(Abar)
NodeInfo <- data.frame(id = newM.node, idx = allidx[newM.node, ])
net <- igraph::graph_from_adjacency_matrix(M, weighted = TRUE,
diag = FALSE, mode = "undirected")
# Vertex Color and Shape Definition
k <- length(newM.node)
unique_types <- unique(sub_type)
type_colors <- c("darkviolet", "darkred", "midnightblue", "forestgreen", "deeppink")  # Darker color alternatives
#type_colors <- c("purple", "dark orange", "blue", "green", "pink")  # Extend color list as needed
type_shapes <- c("square", "circle", "triangle", "diamond", "rectangle")  # Extend shape list as needed
vcol <- type_colors[match(sub_type[newM.node], unique_types)]
vshape <- type_shapes[match(sub_type[newM.node], unique_types)]
lcol <- vcol
# If not show nodes.
if(!ShowNodes){vshape <- "none"}
# If no label, assign a place holder.
if(!ShowTypeLabel){node_names <- rep(" ", length(newM.node))}
# Define edge colors.
ecol <- rep("gray80", igraph::ecount(net))
ew <- abs(igraph::edge.attributes(net)$weight) * 5
#ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"
#ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "red"
ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "lightblue"  # Lighter blue for negative edges
ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "coral"  # Lighter red for positive edges
# Define network layout.
if(NetLayout == "circle"){
l <- igraph::layout_in_circle(net)
}else if(NetLayout == "sphere"){
l <- igraph::layout_on_sphere(net)
}else if(NetLayout == "fr"){
l <- igraph::layout_with_fr(net)
}else if(NetLayout == "lgl"){
l <- igraph::layout_with_lgl(net)
}else{
stop("Unrecognized NetLayout input. Acceptable options are 'circle',
'sphere', 'fr', and 'lgl'.")
}
# Plotting the network
graphics::plot(net, vertex.color = vcol, vertex.shape = vshape,
vertex.label.cex = VertexLabelCex, layout = l,
vertex.size = VertexSize, vertex.label = node_names,
edge.width = ew, vertex.label.color = lcol, edge.color = ecol,
vertex.label.font = 2, main = PlotTitle)
}
}
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 0.8, VertexSize = 1)
plotMultiOmicsNetwork <- function(Abar, CorrMatrix,
ModuleIdx = 1, sub_type, CorrCutOff = 0.2,
AddCorrSign = TRUE,
ShowTypeLabel = TRUE,
PlotTitle = "", NetLayout = "lgl",
ShowNodes = TRUE,
VertexLabelCex = 1, VertexSize = 1){
p <- ncol(Abar)
# Trim the module by CorrCutOff.
M <- as.matrix(Abar)
CorrSubMatrix <- as.matrix(CorrMatrix)
M[which(abs(CorrSubMatrix) < CorrCutOff)] <- 0
if(AddCorrSign){M <- M * sign(CorrSubMatrix)}
M.node <- 1:nrow(Abar)
newM.node <- M.node[which(apply(abs(M), 1, max) > 0)]
# Get the actual names of the nodes from the row names of Abar
node_names <- rownames(Abar)[newM.node]
if(length(newM.node) == 0){
print("No edge passes threshold.")
}else{
M <- M[newM.node, newM.node]
allidx <- matrix(seq_len(p), ncol = 1)
rownames(allidx) <- rownames(Abar)
NodeInfo <- data.frame(id = newM.node, idx = allidx[newM.node, ])
net <- igraph::graph_from_adjacency_matrix(M, weighted = TRUE,
diag = FALSE, mode = "undirected")
# Vertex Color and Shape Definition
k <- length(newM.node)
unique_types <- unique(sub_type)
type_colors <- c("darkviolet", "darkred", "midnightblue", "forestgreen", "deeppink")  # Darker color alternatives
#type_colors <- c("purple", "dark orange", "blue", "green", "pink")  # Extend color list as needed
type_shapes <- c("square", "circle", "triangle", "diamond", "rectangle")  # Extend shape list as needed
vcol <- type_colors[match(sub_type[newM.node], unique_types)]
vshape <- type_shapes[match(sub_type[newM.node], unique_types)]
lcol <- vcol
# If not show nodes.
if(!ShowNodes){vshape <- "none"}
# If no label, assign a place holder.
if(!ShowTypeLabel){node_names <- rep(" ", length(newM.node))}
# Define edge colors.
ecol <- rep("gray80", igraph::ecount(net))
ew <- abs(igraph::edge.attributes(net)$weight) * 5
#ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "blue"
#ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "red"
ecol[which(igraph::edge.attributes(net)$weight < 0)] <- "skyblue"  # Lighter blue for negative edges
ecol[which(igraph::edge.attributes(net)$weight > 0)] <- "coral"  # Lighter red for positive edges
# Define network layout.
if(NetLayout == "circle"){
l <- igraph::layout_in_circle(net)
}else if(NetLayout == "sphere"){
l <- igraph::layout_on_sphere(net)
}else if(NetLayout == "fr"){
l <- igraph::layout_with_fr(net)
}else if(NetLayout == "lgl"){
l <- igraph::layout_with_lgl(net)
}else{
stop("Unrecognized NetLayout input. Acceptable options are 'circle',
'sphere', 'fr', and 'lgl'.")
}
# Plotting the network
graphics::plot(net, vertex.color = vcol, vertex.shape = vshape,
vertex.label.cex = VertexLabelCex, layout = l,
vertex.size = VertexSize, vertex.label = node_names,
edge.width = ew, vertex.label.color = lcol, edge.color = ecol,
vertex.label.font = 2, main = PlotTitle)
}
}
plotMultiOmicsNetwork(Abar = as.matrix(M), ShowTypeLabel = TRUE,CorrMatrix = correlation_sub, sub_type = sub_type,CorrCutOff = 0.05,NetLayout == "lgl", VertexLabelCex = 0.8, VertexSize = 1)
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::build_vignettes()
devtools::build_manual()
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::document()
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::document()
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::build(args = "--compact-vignettes=gs+qpdf")
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::build_vignettes()
rmarkdown::render()
devtools::build_vignettes()
devtools::build_vignettes()
VignetteBuilder: rmarkdown
devtools::build_vignettes()
devtools::build_vignettes()
library(BiocStyle, lib.loc = "C:/Users/liux4/AppData/Local/R/win-library/4.2")
remove.packages("BiocStyle", lib="C:/Users/liux4/AppData/Local/R/win-library/4.2")
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
knitr::opts_chunk$set(echo = TRUE)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocStyle")
BiocManager::install("BiocStyle")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("BiocStyle")
library(BiocStyle)
devtools::build_vignettes()
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::build_vignettes()
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build(args = "--compact-vignettes=gs+qpdf")
library(SmCCNet)
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::build_vignettes()
devtools::build(args = "--compact-vignettes=gs+qpdf")
getwd()
system("git clone https://github.com/KechrisLab/SmCCNet")
ssh-keygen -t rsa -b 4096 -C "liux4283@umn.edu"
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::document()
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
devtools::document()
getwd()
setwd('C:/Users/liux4/OneDrive/Documents/SmCCNet-master')
devtools::document()
devtools::document()
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics("figures/SmCCNetWorkflow.pdf")
knitr::include_graphics("figures/SmCCNetWorkflow.pdf")
knitr::include_graphics("figures/SmCCNetWorkflow.pdf")
knitr::include_graphics("figures/SmCCNetWorkflow.pdf")
knitr::include_graphics("figures/SmCCNetWorkflow.pdf")
knitr::include_graphics("figures/SmCCNetWorkflow.pdf")
devtools::check(build_args = "--compact-vignettes=gs+qpdf")
